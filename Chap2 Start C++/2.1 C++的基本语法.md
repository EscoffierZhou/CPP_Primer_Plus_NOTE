# 2.1 C++的基本语法

```cpp
// 1.myfirst.cpp
#include <iostream> // 预处理器编译指令
int main()
{
    using namespace std;   
    cout << "C++ programme";
    cout << endl;
    cout << "A simple output" << endl;
    return 0;       // terminate main()
}
```

该示例包含:注释+预处理器编译指令+函数头+函数体+输入输出+结束语句

**C++98中会在`int main()`最后自动添加`return 0;`**

****

## **1.`main()`函数**

1.main()函数

>```cpp
>int main()
>{
>    statements
>    return 0; // return statement,对接操作系统
>}
>```
>
>`main()`函数不接受任何参数的传入

2.int类型表示函数最后的返回值是整型

>可替代的写法:`int main()`/`main()`/`int main(void)`/`void main()`
>
>**传统的ANSI/ISOC++标准是必须要有返回值的,现在倒是无所谓了**

`main()`函数在程序中必须存在,因为程序需要从该函数开始执行->未定义错误

如果是动态链接库(DLL)模块(控制器芯片)可能不要`main()`但仍有``_tmain()``

*函数体:`function(argument list)`*

## **2.C++注释**

使用`//`来作为行注释

使用`/* */`来作为块注释(C风格)

## **3.C++预处理器和iostream文件**

这里`iostream`文件是一个标准的头文件

然而`#include<iostream>`是一种对基本C++进行编译的预处理器指令

>头文件:核心是声明(函数原型/类定义/模板定义/常量和宏定义)
>
>预处理器:寻找以`#`开头的预处理器指令(编译指令),对文本进行修改

`iostream`:(input-output-stream)输入输出流

>标准头模块`istream`,`ostream`
>
>`#pragma`:编译器指令,`#define`和`#undef`:辅助宏
>
>`__PURE_APPDOMAIN_GLOBAL`:复杂的跨平台宏

<font color=red>原始文件并没有被修改,源代码文件和iostream组成复合文件进行编译</font>

>   源文件是不可侵犯的蓝图,编译系统中的任何工具都只会读取源文件
>
>   编译过程是单向的
>
>   **源代码->翻译单元->汇编(.s)->目标文件(.o.obj)->可执行文件(.exe)**
>
>   预处理阶段:会将头文件的全部文本内容粘贴到**翻译单元**

## **4.头文件h**

**头文件是支持一组特定工具的文件**

`iostream`是一种包含文件,包含于其它文件之中

| C++ old | iostream.h | C++可用                |
| ------- | ---------- | ---------------------- |
| C old   | math.h     | C/C++都可用            |
| C++ new | iostream   | C++可用(namespace std) |
| C new   | math       | C++可用(namespace std) |

**要将模板写入header的重要原因:在link的时候判断重复定义**

## **<font color=red>5.namespace</font>**

`using namespace std;`是using编译指令(Chap9再学)

>   如果当前作用域中找不到该名字,请去`std`这个空间找一下
>
>   "`std`命名空间"和"文件"是完全两个不同的概念,前者是多个不同头文件
>
>   `#include<iostream>`:将`class ostream`,`class istream`等都放到`std`
>
>   ```cpp
>   #pragma once // 防止重复包含
>   #include <ostream> // iostream 内部会包含更基础的头文件
>   #include <istream>
>   // 注意这里：它打开了 std 命名空间
>   namespace std {
>       // 在这里声明和定义了 cout, cin, cerr 等
>       extern ostream cout;
>       extern istream cin;
>       extern ostream cerr;
>       // ... 其他 iostream 相关的东西
>   } 
>   ```
>
>   `#include<vector>`:将`template<...>class vector`放到`std`
>
>   ```cpp
>   #pragma once // 防止重复包含
>   #include <initializer_list> 
>   // 注意这里：它也打开了同一个 std 命名空间
>   namespace std {
>       // 在这里定义了 vector 模板类
>       template<
>           class T,
>           class Allocator = std::allocator<T>
>       > class vector {
>           // ... vector 的所有成员函数、变量等等
>       };
>   } 
>   ```
>
>   `#include<string>`:将`class basic_string`...放到`std`

namespace名称空间存在的意义就是对相同命名的函数进行选择(报错)

```cpp
// 比如 CIEL 和 KAF 公司产品都有KAMITSUBAKI()函数
KAMITSUBAKI("1st ONE-MAN LIVE");//error 'KAMITSUBAKI' not defined
    
using namespace CIEL;
KAMITSUBAKI("1st ONE-MAN LIVE"); // 哦哦哦
// ->
CIEL::KAMITSUBAKI("1st ONE-MAN LIVE");
```

**所以如果使用C++的标准组件,即名为`std::component()`**可以偷懒

```cpp
# 完整写法
std::cin >> CIEL;
std::cout << "I LOVE CIEL"<< std::endl;
# lazy approach
using namespace std;
cin >> CIEL;
cout << "I LOVE CIEL"<< endl;
```

**如果命名空间中包含相同命名的用法,会在链接(link)中报错**

>`header1.cpp`中的`namespace`存在`FUNCTION()`用法,编译成功`header1.o`
>
>`header2.cpp`中的`namespace`存在`FUNCTION()`用法,编译成功`header2.o`
>
>`main.cpp`中存在调用方式`namespace::FUNCTION`,编译成功`main.o`
>
>`main.o`, `header1.o,` `header2.o`违反单一定义规则 (ODR)
>
>>   一个非 inline 的变量或函数**只能被定义一次**。
>>
>>   ```cpp
>>   multiple definition of 'A::FUNCTION()'
>>   LNK2005: "void __cdecl A::FUNCTION(void)" already defined in header1.obj
>>   ```
>>
>>   **编译器无法选择**

## **<font color=red>6.`cout`和函数运算符重载</font>**

(这里默认使用了lazy approach,即`std::cout`)

1.输出文字流:`cout << "My waifu CIEL";`

2.输出文字对象:`cout << sentence << endl`

**(其中`<<`将字符串发送给cout,cout是一个预定义的对象[类的示例])**

**函数运算符重载`<`:通过重载使得运算符根据上下文有不同的含义**

>   C中的&:可以表示地址运算符,可以表示按位AND运算符
>
>   C中的\*:可以表示乘法运算符,可以表示指针解出引用

## **7.控制符`endl`**

`endl`是作用于`cout`的符号,因此被称作控制符(manipulator)

其主要作用就是将光标移动到下一行开头

可以在语句之后声明;可以单独起一行声明

**当然转义序列`\n`也可以在C++中使用,直接加入语句最后**

## **8.C++的书写标准**

每个token之间必须分开,token之间不要产生冲突

空格和回车在不影响token的前提下可以随便整

每条语句占一行

每个函数都有两个花括号(每个花括号各占一行)

函数中的语句都相对于花括号进行缩进

**圆括号周围没有空白**

## **9.HUAWEI华为C++编写标准**

>   ```cpp
>   变量
>   【规则】指针变量、表示资源描述符的变量、BOOL变量声明必须赋予初值
>   
>   【规则】指向资源句柄或者描述符的变量，在资源释放后立即赋予新值
>   
>   【规则】类成员变量必须在构造函数中赋予初值
>   
>   【规则】不对指针变量进行sizeof操作
>   
>   【建议】尽量使用const
>   
>   【建议】如果全局变量的访问涉及多个线程，需要考虑多线程竞争条件问题。
>   
>   【建议】同一个函数内，局部变量所占用的空间应小于16KB
>   ```
>
>   ```cpp
>   函数
>   【规则】数组作为函数参数时，必须同时将其长度作为函数的参数
>   
>   【规则】不对内容进行修改的指针型参数，定义为const
>   
>   【建议】谨慎使用不可重入函数
>   
>   【建议】字符串或指针作为函数参数时，请检查参数是否为NULL
>   ```
>
>   ```cpp
>   循环
>   【规则】循环必须有退出条件
>   ```
>
>   ```cpp
>   类
>   【规则】如果构造函数中分配了需要手动释放的资源，则必须有析构函数
>   
>   【规则】构造函数内不能做任何可能失败的操作
>   
>   【规则】严禁在构造函数中创建线程
>   
>   【规则】严禁出现delete this操作
>   
>   【建议】尽量避免定义public成员
>   ```
>
>   ```cpp
>   字符串/数组操作
>   【规则】确保有足够的存储空间
>   
>   【规则】对字符串进行存储操作，确保字符串有'\0'结束符
>   
>   【规则】外部数据作为数组索引时必须确保其在数组大小范围内
>   
>   【规则】外部数据作为复制内存操作函数的长度时，需要校验其合法性
>   
>   【规则】调用格式化函数时，禁止format参数由外部可控
>   
>   【规则】调用格式化函数时，format中参数的类型与个数必须与实际参数类型一致
>   ```
>
>   ```cpp
>   整数
>   【规则】整数之间运算时必须严格检查，确保不会出现溢出、符号反转或除以0。
>   
>   【规则】整型表达式比较或赋值为一种更大类型，必须先用这种更大类型对它进行求值
>   
>   【规则】禁止对有符号整数进行位操作运算
>   
>   【规则】禁止整数与指针间互相转化
>   
>   【规则】循环次数如果受外部数据控制，需要校验其合法性
>   
>   【规则】禁止对指针进行逻辑或位运算
>   ```
>
>   ```cpp
>   内存
>   【规则】内存申请前，必须对申请内存大小进行合法性校验
>   
>   【规则】内存分配后必须判断是否成功
>   
>   【规则】禁止引用未初始化的内存
>   
>   【规则】内存释放之后立即赋予新值
>   ```

