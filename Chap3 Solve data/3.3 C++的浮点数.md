# 3.3 C++的浮点数

**在C++中,浮点数被存储为`基准值`+`缩放因子(小数点移动的位置)`**

## **1.书写浮点数**

1.标准小数点表示法:`12.34`,`0.00023`

2.E表示法(不能有空格):

>   `3.45E6`(表示`3.45`和`1000000`相乘的结果)
>
>   `8.33E~4`(表示`8.33`和`10000`相除的结果)
>
>   `2.52e+9`(表示`2.52`小数点向右移动`9`位)
>
>   `9.11e-31`(表示`9.11`小数点向左移动`31`位)
>
>   (即可以用E也可以用e)

****

## **2.浮点数类型`float`/`double`/`long double`**

`float`至少32位;`double`至少48位;`long double`一般为128位

>   同时指数范围至少是`-37`到`37`

```cpp
//3.8 floatnum.coo
#include<iostream>
int main()
{
    using namespace std;
    cout.setf(ios_base::fixed,ios_base::floatfield); // 常量
    float tub = 10.0 / 3.0  ; // 一般输出6位
    double mint = 10.0 / 3.0 ;// 一般输出15位
    const float million = 1.0e6;
    
    cout << "tub = " << tub;
    cout << " , a million tub = " << million * tub;
    cout << ".\nand ten million tubs = ";
    cout << 10 * million * tub << endl;
    
    cout << "mint = " << mint << " and a million mints";
    cout << million * mint <<endl;
    return 0;
}
// tub = 3.333333 , a million tub = 3333333.250000.
// and ten million tubs = 33333332.000000
// mint = 3.333333 and a million mints3333333.333333
```

>   **1.`cout.setf()`的作用是避免`cout`删除结尾的0**
>
>   **2.通过大数乘法可以看出来浮点数产生的结果不准确**

****

## **3.浮点常量**

默认为`double`,可通过f或F后缀转化为`float`,可通过l或L转为`long double`

```cpp
1.234f 		// float
2.45E20F 	// float
2.3453E28 	// double
2.2L 		// long double
```

****

## **4.浮点数的优缺点**

优点:1.表示小数 2.表示的范围大得多

缺点:1.计算速度慢 2.精度降低(**注意`float`只能保证6位有效位**)

```cpp
// fltadd.cpp
#include<iostream>
int main()
{
    using namespace std;
    float a = 2.34E+22f;
    float b = a + 1.0f;
    cout << b - a << endl; // 应该输出1.0,但是实际输出0
    return 0;
}
```

