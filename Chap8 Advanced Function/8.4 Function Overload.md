# 8.4 Function Overload

**函数重载的关键是函数的参数列表(params list),函数特征标**

```cpp
// 编译器会根据具体采用的params来匹配
void print(const char * str,int width);
void print(double d,int width);
void print(long l,int width);
void print(int i,int width);
void print(const char *str);
```

>   **如果没有任何prototype则使用标准类型cast转换然后进行匹配**
>
>   **->如果经过转化后有多个原型匹配,则拒绝该函数调用**

**需要额外注意引用**

>   前面提到,引用和原变量在编译器的视角都相同,只不过变了个名
>
>   所以`double x`和`double &x`原型都会匹配,编译不成功
>
>   **然后重载只看params的类型,和params名字无关**

```cpp
void dribble(char *bits); // overload
void dribble(const char * cbits) // overload
void dabble(char *bits); // not overload(函数名不同,额外声明)
void drivel(const char *bits) // not overload(函数名不同,额外声明)
    
const char p1[20] = "How's the weather?";
char p2[20] = "How's the Business?";

dribble(p1); // const char *
dribble(p2); // char *
dabble(p1);  // no-match
dabble(p2);  // char *
// 非const值赋值给const变量是合法的
drivel(p1);	 // const char*
drivel(p2);  // const char*
```

**不能声明多个相同函数名和形参列表的函数**

>   ```cpp
>   // 相同的函数名传入相同类型的参数,不知道用哪个
>   long grok(int n,float m);
>   double grok(int n,float m);
>   // 这样就可以
>   double grok(double n,float m);
>   ```

## 1.Overload `lvalue` `rvalue`

```cpp
void staff(double & rs);
void staff(const double & rcs);

void stove(double & r1);		
void stove(const double & r2); 
void stove(doubel && r3);
// 1.左值参数:左值参数匹配
// 2.const左值参数:左值参数,const左值参数,右值参数匹配
// 3.左值&参数:左值&参数匹配
double x = 55.5;
const double y = 32.0;
stove(x);	// para:double &
stove(y);	// para:const double &
stove(x+y); // para:double &&
```

**下面的程序目的:它返回整数的前n位(整数)**

```cpp
// 8.10 leftover.cpp
#include<iostream>
unsigned long left(unsigned long num,unsigned ct);
char *left(const char * str,int n = 1);
int main()
{
    using namespace std;
    char * trip = "HAWAII!!";
    unsigned long n = 12345678;
    int i;
    char * temp;
    for(i = 1; i < 10;i++)
    {
		cout << left(n,i) << endl;
        temp  = left(trip,i);
        cout << temp << endl;
        delete[] temp;
    }
    return 0;
}
unsigned long left(unsigned long num,unsigned ct)
{
	unsigned digits = 1;
    unsigned long n = num;
    if(ct == 0 || num == 0)
        return 0;
    while(n /= 10)
        digtis++;
    if(digits > ct)
    {
        ct = digits - ct;
        while(ct--)
        	num /= 10;
    	return num;
    }
    else
        return num;
}
// left函数返回一个新string的指针(含前n位的)
char * left(const char * str,int n)
{
    if (n<0)
        n=0;
    char *p = new char[n-1];
    int i;
    for(i = 0;i < n && str[i];i++)
        p[i] = str[i];
    while(i <= n)
        p[i++] = '\0';
    return p;
}
```

## 2.何时使用函数重载?

仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载

**如果调用的参数类型不同,那么一定要写完整的重载函数**

>   C++是静态语言,不存在第一个参数符合,后面参数直接猜的情况
>
>   (即,参数列表中的参数是调用的时候所有的参数)
>
>   调用的时候只少不多(少的时候可以设置默认值,或者换版本)