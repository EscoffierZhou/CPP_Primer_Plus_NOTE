# 8.2 Reference variables

**C++新增了一种复合类型——引用变量。**

>   引用是已定义的变量的别名（另一个名称）。引用变量的主要用途是用作函数的形参。**通过将引用变量用作参数，函数将使用原始数据，而不是其副本。**
>
>   这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。然而，介绍如何将引用用于函数之前，先介绍一下定义和使用引用的基本知识。请记住，下述讨论旨在说明引用是如何工作的，而不是其典型用法

## 1.创建引用变量

前面讲过，C和C++使用&符号来指示变量的地址。C++给&符号赋
予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量
的别名，可以这样做:

```cpp
int rats;
int & rodents = rats;
```

>其中，&不是地址运算符，而是类型标识符的一部分(指向int的引用)

```cpp
// 8.2 firstref.cpp
#include<iostream>
int main()
{
    using namespace std;
    int rats = 101;
    int & rodents = rats; // reference
    cout << rats << rodents << endl;
    rodents++;
    cout << rats << rodents << endl;
    cout << &rats;		  // address
    cout << &rodents << endl;
    return 0;
}
```

>   结果是`rats`和`rodents`的值和地址完全相同,修改一个就会同时改变两个值
>
>   **和指针地址的差别是:在声明的时候就需要初始化(类似`const`)**
>
>   ```cpp
>   int & rodents = rats;
>   int * const pr = &rats; // 上面代码的完整形式
>   ```

**`&`的连锁修改性**

```cpp
// secref.cpp
#inlcude<iostream>
{
    using namespace std;
    int rats = 101;
    int & rodents = rats;
    cout << rats << endl;
    cout << rodents << endl;
    cout << &rats << endl;
    cout << &rodents << endl;    
    
    int bunnies = 50;
    rodents = bunnies;
    // 尝试修改reference的对象,结果把源对象的值给修改了
    // 一种不同于const的严格方式,可以对变量值和变量引用进行重赋值
    cout << bunnies << endl;
    cout << rats << endl;
    cout << rodents << endl;
    cout << &bunnies << endl;
    cout << &rodents << endl;    
    return 0;
   
}
```

>   **当然之前提到`&`的位置是`const`不可修改**
>
>   ```cpp
>   int rats = 101;
>   int *pt = &rats;
>   int &rodents = *pt;
>   int bunnies = 50;
>   pt = &bunnies;	// 即使引用在指针上,也并不会修改一开始引用的值
>   ```

## 2.将引用用作函数参数

引用经常被用作函数参数，使得**函数中的变量名成为调用程序中的变量的别名**

>   **这种传递参数的方法称为按引用传递**
>
>   (按值传递:2个变量,2个名称;按引用传递:1个变量,2个名称)
>
>   ![image-20250807211256570](./assets/image-20250807211256570.png)

```cpp
// 8.4 swaps.cpp

```

