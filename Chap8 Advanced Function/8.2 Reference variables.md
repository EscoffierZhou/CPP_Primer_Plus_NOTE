# 8.2 Reference variables

**C++新增了一种复合类型——引用变量。**

>   引用是已定义的变量的别名（另一个名称）。引用变量的主要用途是用作函数的形参。**通过将引用变量用作参数，函数将使用原始数据，而不是其副本。**
>
>   这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。然而，介绍如何将引用用于函数之前，先介绍一下定义和使用引用的基本知识。请记住，下述讨论旨在说明引用是如何工作的，而不是其典型用法

## 1.创建引用变量

前面讲过，C和C++使用&符号来指示变量的地址。C++给&符号赋
予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量
的别名，可以这样做:

```cpp
int rats;
int & rodents = rats;
```

>其中，&不是地址运算符，而是类型标识符的一部分(指向int的引用)

```cpp
// 8.2 firstref.cpp
#include<iostream>
int main()
{
    using namespace std;
    int rats = 101;
    int & rodents = rats; // reference
    cout << rats << rodents << endl;
    rodents++;
    cout << rats << rodents << endl;
    cout << &rats;		  // address
    cout << &rodents << endl;
    return 0;
}
```

>   结果是`rats`和`rodents`的值和地址完全相同,修改一个就会同时改变两个值
>
>   **和指针地址的差别是:在声明的时候就需要初始化(类似`const`)**
>
>   ```cpp
>   int & rodents = rats;
>   int * const pr = &rats; // 上面代码的完整形式
>   ```

**`&`的连锁修改性**

```cpp
// secref.cpp
#inlcude<iostream>
{
    using namespace std;
    int rats = 101;
    int & rodents = rats;
    cout << rats << endl;
    cout << rodents << endl;
    cout << &rats << endl;
    cout << &rodents << endl;    
    
    int bunnies = 50;
    rodents = bunnies;
    // 尝试修改reference的对象,结果把源对象的值给修改了
    // 一种不同于const的严格方式,可以对变量值和变量引用进行重赋值
    cout << bunnies << endl;
    cout << rats << endl;
    cout << rodents << endl;
    cout << &bunnies << endl;
    cout << &rodents << endl;    
    return 0;
   
}
```

>   **当然之前提到`&`的位置是`const`不可修改**
>
>   ```cpp
>   int rats = 101;
>   int *pt = &rats;
>   int &rodents = *pt;
>   int bunnies = 50;
>   pt = &bunnies;	// 即使引用在指针上,也并不会修改一开始引用的值
>   ```

## 2.将引用用作函数参数

引用经常被用作函数参数，使得**函数中的变量名成为调用程序中的变量的别名**

>   **这种传递参数的方法称为按引用传递**
>
>   (按值传递:2个变量,2个名称;按引用传递:1个变量,2个名称)
>
>   ![image-20250807211256570](./assets/image-20250807211256570.png)

```cpp
// 8.4 swaps.cpp
#include<iostream>
void swapr(int &a,int &b);
void swapp(int *p,int *q);
void swapv(int a,int b);
int main()
{
    using namespace std;
    int wallet1 = 300;
    int wallet2 = 350;
    cout　<< wallet1 << " " << wallet2 << endl;
    swapr(wallet1,wallet2); // address,使用实参直接初始化a和b
    cout　<< wallet1 << " " << wallet2 << endl;
    swapp(&wallet1,&wallet2);
    cout　<< wallet1 << " " << wallet2 << endl;
    // swap fail
    swapv(wallet1,wallet2); 
    cout　<< wallet1 << " " << wallet2 << endl;
	return 0;
}
// 注意这里要求传入的参数必须为int,否则需要添加const关键字创建临时变量)
void swapr(int &a,int &b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}
void swapp(int *p,int *q)
{
    int temp;
    temp = *p;
    *p = *q;
    *q = temp;
}
// 没有正确修改的原因:a和b位置变化了,但是原来的变量没有修改
void swapv(int a,int b)
{
    int temp;
    temp = a;
    a = b;
    b = temp;
}
```

## 3.引用的属性和特别

```cpp
// 8.5 cubes.cpp
#include<iostream>
double cube(double a);
double refcube(double &a);
int main()
{
    using namespace std;
    double x = 3.0;
    cout << cube(x) << x << endl;   // 27 3
    cout << refcube(x) << x << endl;// 27 27
    return 0;
}
double cube(double a)
{
	a *= a * a;
    return a;
}
double refcube(double &ra)
{
	ra *= ra * ra;
    return ra;
}
```

>   还是和之前的原因一样,cube使用了按值传递,导致原来的x值没有修改
>
>   如果意图是:**仅作为参数读取,则加上`const`关键字**
>
>   ```cpp
>   double refcube(const double &ra);
>   ```
>
>   **同时传递的是值而不是表达式**
>
>   ```cpp
>   // double z = refcube(x + 3.0); INVALID
>   ```
>
>   (原因是无法控制临时变量的生命周期)

**临时变量,引用参数和`const`**

>   如果实参和引用参数不匹配,则会生成临时变量(仅当前参数为`const引用`)
>
>   **生成临时变量的条件**
>
>   >   实参的类型正确,但不是左值
>   >
>   >   实参的类型不正确,但可以转换为正确的类型
>   >
>   >   (左值参数:可被引用的对象,比如变量/数组元素/结构成员/引用/指针)
>   >
>   >   (非左值参数:字面常量和包含多项的表达式)
>
>   ```cpp
>   double refcube(const double &ra);
>   double side = 3.0;
>   double * pd = &side;
>   double & rd = side;
>   long edge = 5L;
>   double lens[4] = {2.0,5.0,10.0,12.0};
>   double c1 = refcube(side);
>   double c2 = refcube(lens[2]);
>   double c3 = refcube(rd);
>   double c4 = refcube(*pd);
>   // 一下情况ra是临时变量,会被正确运算
>   double c5 = refcube(edge);		  // 5.0*5.0*5.0
>   double c6 = refcube(7.0);		  // 7.0*7.0*7.0
>   double c7 = refcube(side + 10.0); // 13*13*13
>   double refcube(const double &ra)
>   {
>       return ra * ra * ra;
>   }
>   ```
>
>   **带来的好处:不局限于`double`类型变量,使得其它变量也可以进行计算**
>
>   (自动进行了cast转化,甚至支持不同返回值函数的嵌套转换)
>
>   **`const`保证了这个临时变量不会被修改,使用后就消失**
>
>   >   使用`const`可以避免无意间的修改数据
>   >
>   >   使用`const`可以同时处理`const`和非`const`实参
>   >
>   >   使用`const`可以让函数正确生成临时变量
>
>   **右值引用:可以指向右值,使用`&&`声明**
>
>   >   ```cpp
>   >   double && ref = std::sqrt(36.00);
>   >   double j = 15.0;
>   >   double && jref = 2.0 * j + 18.5;
>   >   ```

## 4.将引用用于结构

引用十分适合用于结构和类,而不是基本的内置类型

```cpp
// prrototype
void set_pc(free_throws & ft);
void set_pc(const free_throws & ft);
struct free_throws
{
	std::string name;
    int made;
    int attempts;
    float percent
};

```

```cpp
// 8.6 strtref.cpp
#include<iostream>
#include<string>
struct free_throws
{
    std::string name;
    int made;
    int attempts;
    float percent;
};
void display(const free_throws & ft);
void set_pc(free_throws & ft);
free_throws & accumulate(free_throws & target,const free_throws & source); // 相当于两个const&引用
int main()
{
	free_throws one = {"Ifelsa Branch",13,14};
    free_throws two = {"Andor Knott",10,16};
    free_throws three = {"Minnie Max",7,9};
    free_throws four = {"Whily Looper",5,9};
    free_throws five = {"Long Long",6,14};
    free_throws team = {"Throwgoods",0,0};
    
    free_throw dup;
    // 4 functions
    set_pc(one);
    display(one);
    accumulate(team,one);
    display(team);
    // using return value as argument
    display(accumulate(team,two));
    accumulate(accumulate(team,three),four);
    display(team);
    // using return value in assignment
    dup = accumulate(team,five); // 将整个结构都复制到一个临时位置
    display(team);
    display(dup);
    set_pc(four);
    // ill-advised assignment 不明智的赋值
    // 首先会通过&修改dup本身(accumulate方法)
    // 然后返回一个对dup对象的引用
    accumulate(dup,five) = four;
 // 相当于accumulate(dup,five);dup=four;(使用five初始化然后修改为four)
    display(sup);
    return 0;
}
void display(const free_throws & ft)
{
    using std::cout;
    cout << ft.name << endl;
    cout << ft.made << endl;
    cout << ft.attempts << endl;
    cout << ft.percent << endl;
}
void set_pc(free_throws & ft)
{
    if(ft.attempts != 0)
        ft.percent = 100.0f * float(ft.made)/float(ft.attempts);
    else
        ft.percent = 0;
}
free_throws & accumulate(free_throws & target,const free_throws & source)
{
	target.attempts += source.attempts;
    target.made += source.made;
    set_pc(target);
    return target;
}
```

