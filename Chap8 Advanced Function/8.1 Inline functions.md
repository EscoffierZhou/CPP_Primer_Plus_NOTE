# 8.1 Inline functions

内联函数(`inline`)是C++为提高程序运行速度所做的一项改进。

常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它
们组合到程序中。要了解内联函数与常规函数之间的区别，必须深入到程序内部。

编译过程的最终产品是可执行程序——由一组机器语言指令组成。

**运行程序**

>   运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令
>   都有特定的内存地址。计算机随后将**逐步执行**这些指令。**有时将跳过**一些指令（如有循环或分支语句时），向前或向后跳到特定地址。**常规函数调用也使程序跳到另一个地址**（函数的地址），并在函数结束时返回。

**详细过程**

>   执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并**将函数参数复制到堆栈**（为此保留的内存块），**跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的**
>   指令处（这与阅读文章时停下来看脚注，并在阅读完脚注后返回到以前
>   阅读的地方类似）。来回跳跃并记录跳跃位置意味着以前使用函数时，
>   需要一定的开销。

**`inline`内联函数**

>   内联函数的编译代码与其他程序代码“内联”起来了。
>
>   也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本）。
>
>   **也就是说直接使用一个内联函数模板替换需要跳转的位置,需要额外的内存**

**通常的做法是省略原型,将整个定义放在写原型的部分**

```cpp
// inline.cpp
#include<iostream>
inline double square(double x){return x*x;}
int main()
{
    using namespace std;
    double a,b;
    double c = 13.0;
    a = square(5.0);
    b = square(4.5 + 7.5);
    cout << a << " " << b << endl;
    cout << c << endl;
    cout << squre(c++) << endl;	// 首先计算平方值,然后在C++
    cout << c << endl;
    // c:13 169 14
    return 0;
}
```

>   内联函数和常规函数一样,使用**按值传递**,如果是表达式则返回对应的值
>
>   **C++的内联功能远胜过宏定义(因为本身具有函数特性)**
>
>   >   ```cpp
>   >   #define SQUARE(X) X*X   // 一种直接的文本替换,不能按值传递!!
>   >   
>   >   a = SQUARE(5.0); 		// a = 5.0 * 5.0
>   >   // b = SQUARE(4.5 + 7.5);	// INVALID 
>   >   	// 如果使用inline首先得到12,然后计算12 * 12
>   >   // c = SQUARE(C++)			// INVALID
>   >   	// 如果使用inline首先得到6.0,然后计算6 * 6
>   >   ```
>   >
>   >   **所以如果有函数一般不使用宏,而是使用内联函数**