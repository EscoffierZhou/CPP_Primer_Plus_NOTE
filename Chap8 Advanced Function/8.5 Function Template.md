# 8.5 Function Template

**函数模板即通用函数,可以使用泛型来定义函数**

>   **将类型作为参数传递给模板->编译器生成该类型的函数**
>
>   (一种通用编程,模板特性也成为参数化类型)

**比如交换两个字符(可能是`char`/`double`/`int`)需要三个版本,使用Template**

>   ```cpp
>   // C++98之前:template<class AnyType>
>   template<typename AnyType>
>   void Swap(AnyType &a,AnyType &b)
>   {
>       Anytype temp;
>       temp = a;
>       a = b;
>       b = temp;
>   }
>   ```

**更常用的做法是使用`T`代替`Typename`**

```cpp
// 8.11 funtemp.cpp
#include<iostream>
template<typename T>
void Swap(T &a,T &b); // Prototype
int main()
{
    using namespace std;
    
    int i = 10;int j = 20;
    cout << i << " " << j << endl;
    Swap(i,j);
    cout << i << " " << j << endl;
    
    double x = 24.5;double y = 81.7;
    cout << x << " " << y << endl;
    Swap(x,y);
    cout << x << " " << y << endl;
    
    return 0;
}
template <typename T>
void Swap(T &a,T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```

## 1.重载模板

当然相同算法(不同做法)之间可以重载(还是看params list)

```cpp
// 8.12 twotemps.cpp
#include<iostream>
template<typename T> 
void Swap(T &a,T &b);
template<typename T> 
void Swap(T *a,T *b,int n);
void Show(int a[]);
const int Lim = 8;
int main()
{
    using namespace std;
    // basic swap
    int i = 10,j = 20;
    cout << i << " " << j << endl;
    Swap(i,j);
    cout << i << " " << j << endl;
    
    // array swap
    int d1[Lim] = {0,7,0,4,1,7,7,6};
    int d2[Lim] = {0,7,2,0,1,9,6,9};
    Show(d1);
    Show(d2);
    Swap(d1,d2,Lim);
    Show(d1);
    Show(d2);
    return 0;
}
template<typename T>
void Swap(T &a,T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template<typename T>
void Swap(T a[],T b[],int n)
{
    T temp;
    for(int i = 0;i < n;i++)
    {
        temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
void Show(int a[])
{
    using namespace std;
    cout << a[0] << a[1] << "/";
    cout <, a[2] << a[3] << "/";
    for(int i = 4;i < Lim;i++)
        cout << a[i];
    cout << endl;
}
```

## 2.模板的局限性

**即有时候不该操作的数据进行了操作,需要操作的数据操作不了**

>   数组不能直接赋值,结构不能直接比大小,指针/结构/数组不能数乘
>
>   没有结构定义运算符,需要自己重载

## 3.显式具体化

**如果模板是通用蓝图,那么显式具体化是针对某个类型的补丁**

>   提供显式具体化代码(具体化定义),编译器会使用该定义,而不是模板

```cpp
// 编译器的选择原则:非template -> explicit specialization -> template

// 非template
void Swap(job &,job &);

// 显式具体化
template<>					// 这是模板的特例,其中的参数我已经确定
void Swap<job>(job &,job &);// 这里job是数据类型

// template
template <typename T>
void Swap(T&,T&);
```

```cpp
// 8.13 twoswap.cpp
#include<iostream>
template<typename T>
void Swap(T &a,T &b);
struct job
{
    char name[40];
    double salary;
    int floor;
};
template<>
void Swap<job>(job &j1,job &j2);
void Show(job &j);
int main()
{
	using namespace std;
    cout.precision(2);
    cout.setf(ios::fixed,ios::floatfield);
    int i = 10;j = 20;
    cout << i << " "<< j << endl;
    Swap(i,j);
    cout << i << " "<< j << endl;
    
    job sue = {"Susan",73000.60,7};
    job sidney = {"Sidney",78060.72,9};
    Show(sue);
    Show(sidney);
    Swap(sue,sidney);
    Show(sue);
    Show(sidney);
    return 0;
}
template<template T>
void Swap(T &a,T&b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
template<>
void Swap<job>(job &j1,job &j2)
{
    // 仅交换两个结构体的salary和floor
    double t1;
    int t2;
    t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;
    
    t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
}
void Show(job &j)
{
	using namespace std;
    cout << j.name << " " << j.salary << " " << j.floor << endl;
}
```

## 4.实例化和具体化

函数模板不是函数定义,而是一种生成函数的方案

**显式实例化和隐式实例化**

>   生成对应版本的函数定义:模板实例(instantiation)
>
>   >   ->隐式实例化(implicit)
>   >
>   >   (然后对应的是显式实例化(explicit))
>
>   当然可以直接命令编译器进行显式实例化(用`<>`指定类型实例)
>
>   >   ```cpp
>   >   template<>void Swap<int>(int &,int &);
>   >   ```
>
>   当然可以直接命令编译器进行显式实例化(在函数中创建显式实例化)
>
>   >   ```cpp
>   >   template<class T>
>   >   T Add(T a,T b) 
>   >   {
>   >   	retunr a + b;
>   >   }
>   >   // x和m的定义
>   >   cout << Add<double>(x,m) << endl;
>   >   ```

**<font color=red>显式实例化和隐式实例化的使用</font>**

>   主要是在`.h`/包含模板的`.cpp`/`main.cpp`文件分离的时候
>
>   >   一`.h`只有声明没有调用,`main`只有调用,linker找不到特定版本的函数
>
>   解决方法:在`template.cpp`文件中直接显式创建一个模板备用
>
>   ```cpp
>   // swap.cpp
>   #include "swap.h"
>   template<typename T>
>   void Swap(T &a, T &b) {
>       T temp = a;
>       a = b;
>       b = temp;
>   }
>   
>   // 这就是显式实例化！
>   // 告诉编译器：“请在这里生成 Swap<int> 的完整代码。”
>   template void Swap<int>(int &a, int &b);
>   // 如果你还需要double版本，就再加一行
>   template void Swap<double>(double &a, double &b);
>   ```

## 5.编译器使用哪个函数版本

函数模板/函数重载/函数模板重载->需要重载解析

>   1.创建候选函数列表
>
>   2.创建可行函数列表(通过params的数量/类型(包括cast后))
>
>   3.判断是否存在最佳可行函数

**但是除此之外的问题:存在多个可行匹配,需要深入比较**

>   1.完全匹配和最佳匹配:即满足实参-形参对应标
>
>   2.部分排序规则
>
>   >```cpp
>   >// 如果pd是double *类型
>   >template<typename T>
>   >void ShowArray(T arr[],int n);
>   >template<typename T>
>   >void ShowArray(T * arr[],int n);
>   >// 使用第二个,因为该模板假设的类型更具体
>   >```
>
>   3.自行决定(主要是显式声明)
>
>   >```cpp
>   >// 在非模板,模板,显式实例都存在
>   >cout << lesser<>(m,n) << endl; // 那就用模板函数
>   >cout << lesser(x,y) << endl; // 那就用Template,params完全匹配
>   >cout << lesser(a,b) << endl; // 那就用非模板,params不太匹配
>   >cout << lesser<int>(m,n) << endl; // 那就用显式实例化
>   >```

>   **有时候即使两个函数都是完全匹配也可以完成重载解析**
>
>   >   如果引用是非`const`,那么原型是非`const`的优先
>   >
>   >   如果是否为模板函数,非模板函数 > 模板函数
>   >
>   >   如果都是模板函数,更具体的模板(转换次数更少的) > 较省略的模板

## 6.模板函数的发展

**1.C++98:不同的类型进行自动类型提升,运算符重载结果不统一**

>   对具体的某个结果类型是未知的

**2.C++11:`decltype`关键字**

>   使得结果和关系式的类型保持统一
>
>   ```cpp
>   // decltype声明了后序的结果和表达式保持一致
>   // 尾随返回类型：auto占位符 与 -> 的组合,保证编译器实时判断类型
>   // (直接写decltype会因为实例不在作用域而报错)
>   template<typename T, typename U>
>   auto add(T a, U b) -> decltype(a + b) {
>       return a + b;
>   }
>   int main() {
>       auto v1 = add(1, 2);   
>       // T=int, U=int. a+b是int. v1类型是 int.
>       auto v2 = add(1, 2.5); 
>       // T=int, U=double. a+b是double. v2类型是 double.
>       auto v3 = add(3.14, 100);  
>       // T=double, U=int. a+b是double. v3类型是 double.
>       std::string s1 = "Hello, ";
>       std::string s2 = "World!";
>       auto v4 = add(s1, s2); 
>       // T=string, U=string. a+b是string. v4类型是 std::string.
>   }
>   ```
>
>   它能非常精确地推断出表达式的**完整类型**，包括 const 修饰符和值类别
>
>   （左值/右值，这通常体现在是否是引用上）
>
>   ```cpp
>   template<typename T>
>   auto forward_variable(T&& t) -> decltype(t) {
>       return t;
>   }
>   
>   int main() {
>       int x = 10;
>       const int y = 20;
>   
>       // 1. 传入左值 x (类型是 int)
>       // t 的类型是 int&
>       // decltype(t) 推断出的类型是 int&
>       // 所以 forward_variable(x) 返回一个 int&
>       int& ref_x = forward_variable(x);
>       ref_x = 100; // x 的值现在变成了 100
>   
>       // 2. 传入 const 左值 y (类型是 const int)
>       // t 的类型是 const int&
>       // decltype(t) 推断出的类型是 const int&
>       // 所以 forward_variable(y) 返回一个 const int&
>       const int& ref_y = forward_variable(y);
>   
>       // 3. 传入右值 30 (临时变量)
>       // t 的类型是 int&&
>       // decltype(t) 推断出的类型是 int&&
>       // 所以 forward_variable(30) 返回一个 int&&
>       int value = forward_variable(30); 
>   }
>   ```
>
>   