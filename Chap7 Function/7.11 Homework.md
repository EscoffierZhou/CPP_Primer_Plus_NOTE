# 7.11 Homework

## 1.总结

函数是C++的编程模块。要使用函数，必须提供定义和原型，并调用该函数。

函数定义是实现函数功能的代码；

函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，并执行函数的代码。

在默认情况下，C++函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。因此，C++函数通过使用拷贝，保护了原始数据的完整性。
C++将数组名参数视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，因为指针是原始地址的拷贝，但函数将使用指针来访问原始数组的内容。当且仅当声明函数的形参时，下面两个声明才是等价的：`typeName arr[] = typeName *arr;`这两个声明都表明，`arr`是指向`typeName`的指针，但在编写函数代码时，可以像使用数组名那样使用`arr`来访问元素：`arr[i]`。

即使在传递指针时，也可以将形参声明为const指针，来保护原始数据的完整性。由于传递数据的地址时，并不会传输有关数组长度的信息，因此通常将数组长度作为独立的参数来传递。另外，也可传递两个指针（其中一个指向数组开头，另一个指向数组末尾的下一个元素），以指定一个范围，就像STL使用的算法一样。

C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是`char*`（char指针），因此被作为`char*`类型参数传递给函数。C++使用空值字符（`\0`）来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。

C++还提供了string类，用于表示字符串。函数可以接受string对象作为参数以及将string对象作为返回值。string类的方法size( )可用于判断其存储的字符串的长度。

C++处理结构的方式与基本类型完全相同，这意味着可以按值传递结构，并将其用作函数返回类型。然而，如果结构非常大，则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。

C++函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。

C++函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。

## 2.Homework

1．使用函数的3个步骤是什么？

>   **是定义函数、提供原型、调用函数**

2．请创建与下面的描述匹配的函数原型。

>   a．`igor( )`没有参数，且没有返回值。
>
>   >   ```cpp
>   >   void igor(void);
>   >   ```
>
>   b．`tofu( )`接受一个int参数，并返回一个float。
>
>   >   ```cpp
>   >   float tofu(int n);
>   >   ```
>
>   c．`mpg( )`接受两个double参数，并返回一个double。
>
>   >   ```cpp
>   >   double mpg(double miles,double gallons);
>   >   ```
>
>   d．`summation( )`将long数组名和数组长度作为参数，并返回一个long值。
>
>   >   ```cpp
>   >   long summation(long harray[],int size);
>   >   ```
>
>   e．`doctor( )`接受一个字符串参数（不能修改该字符串），返回double值。
>
>   >   ```cpp
>   >   double doctor(const char* str);
>
>   f．`ofcourse( )`将boss结构作为参数，不返回值。
>
>   >   ```cpp
>   >   void ofcourse(boss dude);
>
>   g．`plot( )`将map结构的指针作为参数，并返回一个字符串。
>
>   >   ```cpp
>   >   char *plot(map *pmap);

3．编写一个接受3个参数的函数：int数组名、数组长度和一个int值，并将数组的所有元素都设置为该int值。

>   ```cpp
>   void set_array(int arr[],int size,int value)
>   {
>       for(int i=0;i<size;i++)
>           arr[i] = value;
>   }
>   ```

4．编写一个接受3个参数的函数：指向数组区间中第一个元素的指针、指向数组区间最后一个元素后面的指针以及一个int值，并将数组中的每个元素都设置为该int值。

>```cpp
>void set_array(int* begin,int* end,int value)
>{
>    for(int* pt = begin;pt != end;pt++)
>        pt* = value;
>}
>```

5．编写将double数组名和数组长度作为参数，并返回该数组中最大值的函数。该函数不应修改数组的内容。

>   ```cpp
>   double biggest(const double foot[],int size)
>   {
>   	double max;
>       if(size < 1)
>       {
>           cout << "Invalid" << size << endl;
>           return 0;
>       }
>       else
>       {
>           max = foot[0];
>           for(int i = 1;i < size;i++)
>               if(foot[i] > max)
>                   max = foot[i];
>           return max;
>       }
>   }

6．为什么不对类型为基本类型的函数参数使用const限定符？

>   将const限定符用于指针，以防止指向的原始数据被修改。
>
>   程序传递基本类型（如int或double）时，它将按值传递(自动保护)

7．C++程序可使用哪3种C-风格字符串格式？

>字符串可以存储在char数组中
>
>可以用带双引号的字符串来表示
>
>也可以用指向字符串第一个字符的指针来表示。

8．编写一个函数，其原型如下：

>   ```cpp
>   int replace(char* str,char c1,char c2);
>   ```
>
>   该函数将字符串中所有的c1都替换为c2，并返回替换次数。
>
>   ```cpp
>   int replace(char* str,char c1,char c2)
>   {
>       int count = 0;
>       while(*str)
>       {
>           if(*str == c1)
>           {
>               *str = c2;
>               count++;
>           }
>           str++;
>       }
>       return count;
>   }

9．表达式`*"pizza"`的含义是什么？`"taco" [2]`呢？

>由于C++将“pizza”解释为其第一个元素的地址，因此使用*运算符将得到第一个元素的值，即字符p。
>
>由于C++将“taco”解释为第一个元素的地址，因此它将“taco”[2]解释为第二个元素的值，即字符c。
>
>换句话来说，字符串常量的行为与数组名相同。

10．C++允许按值传递结构，也允许传递结构的地址。如果`glitz`是一个结构变量，如何按值传递它？如何传递它的地址？这两种方法有何利弊？

>`glitz`是一个结构变量,要按值传递它，只要传递结构名`glitz`即可;要传递它的地址，请使用地址运算符`&glitz`
>
>按地址传递可节省时间和内存，但不能保护原始数
>据，除非对函数参数使用了const限定符。另外，按值传递意味着可以使
>用常规的结构成员表示法，但传递指针则必须使用间接成员运算符。

11．函数judge( )的返回类型为int，它将这样一个函数的地址作为参数：将const char指针作为参数，并返回一个int值。请编写judge( )函数的原型。

>   ```cpp
>   int judge(int(*pf)(const char *));

12．假设有如下结构声明：

```cpp
struct applicant{
	char name[30];
    int credit_ratings[3];
};
```

>   a．编写一个函数，它将application结构作为参数，并显示该结构的内容。
>
>   ```cpp
>   void display(applicant ap)
>   {
>       cout << ap.name << endl;
>       for(int i=0;i<3;i++)
>           cout << ap.credit_ratings[i] << endl;
>   }
>   ```
>
>   b．编写一个函数，它将application结构的地址作为参数，并显示该参数指向的结构的内容。
>
>   ```cpp
>   void show(const applicant *pa)
>   {
>       cout << pa->name << endl;
>       for(int i=0;i<3;i++)
>           cout << pa->credit_ratings[i] << endl;
>   }

13．假设函数f1()和f2()的原型如下：

```cpp
void f1(applicant *a);
const char* f2(const applicant *a1,const applicant* a2);
```

>   请将p1和p2分别声明为指向f1和f2的指针；将ap声明为一个数组，它包含5个类型与p1相同的指针；将pa声明为一个指针，它指向的数组包含10个类型与p2相同的指针。使用typedef来帮助完成这项工作。
>
>   ```cpp
>   typedef void(*p_f1)(applicant*);
>   p_f1 p1 = f1;
>   typedef const char* (*p_f2)(const applicant*,const applicant*);
>   p_f2 p2 = f2;
>   p_f1 ap[5];
>   p_f2(*pa)[10];
>   ```