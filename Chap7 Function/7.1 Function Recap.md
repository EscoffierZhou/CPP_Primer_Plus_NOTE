# 7.1 Function Recap

提供函数定义；提供函数原型；调用函数。

```cpp
// 7.1 calling cpp
#include<iostream>
void simple();
int main()
{
    using namespace std;
    simple(); // function calling
    return 0;
}
void simple()
{
	using namespace std;
    cout << "A Function" << endl;
}
```

## 1.定义函数

可以将函数分为两类:有返回值的和无返回值的(`void`)

```cpp
void functionName(params)
{
    statements;
}

// 对于有返回值的函数,必须使用返回语句
typeName functionName(params) // int/double...
{
    statements;
    return; 
}
```

>   函数通过将返回值复制到CPU寄存器或内存单元中(将其返回)
>
>   然后调用程序查看该内存单元

**函数的返回值是可以选择具体值的/可以直接使用表达式**

```cpp
int bigger(int a,int b)
{
    if(a < b)
        return a;
    else 
        return b;
}

// 返回一个可以求出值的表达式
double cube(double x)
{
    return x*x*x;
}
```

## 2.函数原型和函数调用

```cpp
#include<iostream>
void cheers(int);
double cube(double x);
int main()
{
    using namespace std;
    cheers(5);
    double side;
    cin >> side;
    double value = cube(side);
    cout << side << endl;
    cout << volume << endl;
    cheers(cube(2)) // 原型保护启用(prototype protection)
    return 0;
}
void cheers(int n)
{
    using namespace std;
    for(int i=0;i<n;i++)
        cout << "Cheers";
    cout << endl;
}
double cube(double x)
{
    return x*x*x;
}
```

**1.为什么要提供原型**

>C++编译器自上而下处理代码,如果调用了一个未见过的函数,编译器会报错
>
>(编译器为了效率不会往后继续在所有文件查找这个函数)
>
>**同时C++支持多文件单独编译链接,所以成本过高**

**2.函数原型的语法**

>   ```cpp
>   double cube(double x); // get prototype
>   double cube(double)    // VALID
>   ```
>
>   ```cpp
>   // 但是需要指出的是,如果()内部为空,有不同意义
>   // C++中直接表示为void
>   // C和Pascal则表示为可以不用填写的参数
>   ```

**3.函数原型的作用**

>(返回值确定)编译器正确处理函数返回值；
>
>(参数个数确定)编译器检查使用的参数数目是否正确；
>
>(参数类型确定)编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型（如果可能的话）。

**4.函数原型对错误类型的转换**

>   如果函数需要一个int值(假设占16位),然而返回的是double值(64位)
>
>   则函数将直接解释为int类型(当然是合理的转换)
>
>   在编译阶段进行的原型化称作**静态类型检查(static type checking)**
