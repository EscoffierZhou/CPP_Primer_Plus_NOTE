# 7.8 Function Array-Object

**类对象是基于结构的,所以对于`7.7 Function Structure`中的一些思想也可以用**

**比如使用一个`array`对象来存储一年四个季度的开支**

>   `std::array<double,4>expenses;`

**声明方法(prototype)**

>对象声明:`void show(std::array<double,4>da);`
>
>对象+指针声明:`void fill(std::array<double,4>*pa)`

**需要注意模板`array`可以存储基本数据类型+类对象**

```cpp
// 7.15 arobj.cpp
// 使用一个array对象来存储一年四个季度的开支
#include<iostream>
#include<array>
#inclued<string>
// constant data
const int Seasons = 4;
const std::array<std::string,Seasons>Snames = 
{"Spring","Summer","Fall","Winter"};
// function prototype
void fill(std::array<double,Seasons>*pa);
// fill函数用于修改array,所以使用了*
void show(std::array<double,Seasons>da);
// show函数用于展示array,所以代值引用

int main()
{
    std::array<double,Seansons>expenses;
    fill(&expenses);
    show(expenses);
    return 0;
}
void fill(std::array<double,Seansons>*pa) // 这里使用了指针作为形参
{
    using namespace std;
    for(int i=0;i < Seasons;i++)
    {
        cin >> (*pa)[i];
    }
}
void show(std::array<double,Seansons>da)
{
    using namespace std;
    double total = 0.0;
    cout << "Expenses" << endl;
    for(int i=0;i < Seasons;i++)
    {
        cour << Sname[i] << da[i] << endl;
        total += da[i];
    }
    cout << "total" << endl;
}
```

**注意:`const array`对象是在所有函数之前声明的,是全局变量**

>`show()`存在的问题:`expenses`存储了四个值,创建一个新的对象并且复制到其中的效率太低,如果处理的是月份年份的开支,这个问题会更加明显
>
>`fill()`使用了指针处理原始对象,但是代码看上去复杂一点
