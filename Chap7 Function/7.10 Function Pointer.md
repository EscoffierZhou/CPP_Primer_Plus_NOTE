# 7.10 Function Pointer

**和数据项相似,函数也有地址,即机器语言代码的内存的开始地址**

>   可以通过编写函数的一个地址作为参数,让函数之间可以调用

## 1.函数指针的基础知识

>   1.获取函数的地址
>
>   >   直接使用函数名称即可
>
>   2.声明一个函数指针
>
>   >   首先指定指针指向的类型(返回类型和params),相当于一个prototype
>   >
>   >   `double pam(int) // prototype`
>   >
>   >   `double(*pf)(int) // (Correct)pf:function pointer`
>   >
>   >   `double * pf (int) // A function returns double*`
>
>   3.使用函数指针调用
>
>   >   ```cpp
>   >   double pam(int);
>   >   double (*pf)(int);
>   >   pf = pam; 	// pf -> pam()
>   >   
>   >   double x = pam(4);   // 通过函数名的调用
>   >   double y = (*pf)(5); // 通过函数指针的调用
>   >   double y = pf(5)	 // 同样是使用函数指针的调用
>   >   ```
>   >
>   >   **需要注意`pam`的`params`和返回类型必须和`pf`相同**

## 2.函数指针示例

```cpp
// 7.18 fun_ptr.cpp
#include<iostream>
double betsy(int);
double pam(int);
void estimate(int lines,double(*pf)(int));
int main()
{
    using namespace std;
    int code;
    cout << "How many lines you need"<< endl;
    cin >> code;
    cout << "Betsy's estimate" << endl;
    estimate(code,betsy);
    cout << "Pam's estimate" << endl;
    estimate(code,pam);
    return 0;
}
double betsy(int lns)
{
    return 0.05 * lns;
}
double pam(int lns)
{
    return 0.03 * lns + 0.0004 * lns * lns;
}
void estimate(int lines,double(*pf)(int))
{
    using namespace std;
    cout << lines << endl;
    cout << (*pf)(lines) << hours; // 通过指针调用
}
```

**两次调用`estimate()`函数,依次传递`betsy()`地址,另一次传递`pam()`**

## 3.深入函数指针

```cpp
// 函数的声明
const double * f1(const double ar[], int n);
const double * f2(const double [] , int);
const double * f3(const double * , int);
// 这些函数的params看似不同,其实意义相同
// 首先是[]和*的等价,然后是有无函数名的等价

// 函数指针的声明
const double *(*p1)(const double *,int);		// Declare
const double *(*p1)(const double *,int) = f1;	// Initialize
auto p2 = f2									// C++11 Initialize
// 以下两种表达式的输出结果相同:都是先输出函数的返回值,然后是实际值
// 注意在这里返回值是const double *,即实际值的地址
// 注意在这里通过*进行解引用,即实际值
cout << (*p1)(av,3) << *(*p1)(av,3) << endl; 	
cout << p2(av,3) << *p2(av,3) << endl;
```

**1.声明函数指针数组**

```cpp
const double * (*pa[3])(const double * , int) = {f1,f2,f3};
// (*pa)表示函数指针,然后(*pa[3])表示存在3个(*pa)指针的数组
// params:const double * 和 int
```

>   注意这里不可用使用`auto`,它只适用于单值初始化,而不能初始化列表
>
>   **但是声明指针数组pa以后,可以视为一个整体再声明一个相同类型的数组**
>
>   `auto pb = pa;`

**2.调用函数指针数组**

```cpp
// 获取实际值的地址
const double * px = pa[0](av,3);
const double * py = (*pb[1])(av,3);

// 获取实际值
double x = *pa[0](av,3);
double y = *(*pb[1])(av,3);

// 指向指针数组的指针
auto pc = &pa; // 可用于初始化
const double *(*(*pd)[3])(const double * , int) = &pa;
// pd指向函数,*pd是数组,(*pd)[i]是数组元素
// *(*pd)[i]是整个函数的指针,得到函数返回值(const double *)
// *(*(*pd)[i])是对返回值的解引用,得到实际值
```

>   **只需知道`pa`是数组第一个元素的地址,`&pa`是整个数组的指针**
>
>   `pa + 1`是下一个元素的地址,`&pa + 1`是数组a后面12字节内存块的地址
>
>   同时解引用的次数不同:`**&pa == *pa == pa[0];`
>
>   ```cpp
>   // 7.19 arfupt.cpp
>   #include<iostream>
>   const double * f1(const double ar[], int n);
>   const double * f2(const double [], int);
>   const double * f3(const double * , int);
>   int main()
>   {
>   	using namespace std;
>       double av[3] = {1112.3,1542.6,2227.9};
>       // declare pointer to a function
>       const double *(*p1)(const double *, int) = f1; // 手动声明
>       auto p2 = f2; // 自动声明
>       // 先是输出地址:const double *,然后输出确切值
>       cout << (*p1)(av,3) << *(*p1)(av,3) << endl; 
>       cout << p2(av,3) << *p2(av,3) << endl;
>       
>       // Initialize 注意auto不管用
>       const double *(*pa[3])(const double *,int) = {f1,f2,f3};
>       // 使用整体指针
>       auto pb = pa;
>       
>       for(int i = 0;i < 3;i++)
>           cout << pa[i](av,3) << *pa[i](av,3) << endl;
>       for(int i = 0;i < 3;i++)
>           cout << pb[i](av,3) << *pb[i](av,3) << endl;
>       
>       // 声明一个类似的相同数组
>       auto pc = &pa; // 自动
>       cout << (*pc)[0](av,3) << *(*pc)[0](av,3) << endl;
>       const double *(*(*pd)[3])(const double *,int) = &pa; // 自动
>       
>       // 保存返回值
>       const double* pdb = (*pd)[1](av,3);
>       cout << pdb << " " << *pdb << endl;
>       cout << (*(pd)[2])(av,3) << " " << *(*(*(pd)[2]))(av,3);
>       return 0;
>   }
>   
>   const double * f1(const double * ar,int n)
>   {
>       return ar;
>   }
>   const double * f2(const double ar[],int n)
>   {
>       return ar+1;
>   }
>   const double * f3(const double ar[],int n)
>   {
>       return ar+2;
>   }
>   ```
>
>   类的虚方法实现通常都采用了这种技术。所幸的是，这些细节由编译器处理。
>
>   **尤其注意自动类型推断对赋给它的初值类型要求很高,否则会连环事故**

## 4.使用`Typedef`进行简化

```cpp
typedef double real; // 使用real来代替原来的double
typedef const double* (*p_fun)(const double*,int)
// 使用p_fun来代替const double *(*variable)(const double *, int)
const double *(*p1)(const double *, int) = f1;
p_fun p1 = f1;
```

