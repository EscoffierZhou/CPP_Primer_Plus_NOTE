# 7.6 Function Structure

## 1.传递和返回结构

**当结构较小的时候,使用按值传递**

**创建结构体也是创建新的类型的形式**

```cpp
struct travel_time
{
    int hours;
    int mins;
};
// prototype
travel_time sum(travel_time t1,travel_time t2);
```

```cpp
// 7.11 travel.cpp
#include<iostream>
struct travel_time
{
    int hours;
    int mins;
};
const int Mins_per_hr = 60;
travel_time sum(travel_time t1,travel_time t2);
void show_time(travel_time t);

int main()
{
	using namespace std;
    travel_time day1 = {5,45};
    travel_time day2 = {4,55};
    travel_time trip = sum(day1,day2);
    cout << "Total\n";
    show_time(trip);
    travel_time day3 = {4,32};
    cout << "Three-day\n";
    show_time(sum(trip,day3));
    return 0;
}
travel_time sum(travel_time t1,travel_time t2)
{
    travel_time total;
    total.mins = (t1.mins + t2.mins) % Mins_per_hr;
    total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr;
    return total;
}
void show_time(travel_time t)
{
    using namespace std;
    cout << t.hours << endl;
    cout << t.mins << endl;
}
```

## 2.处理结构体的示例

**1.使用直角坐标系**

```cpp
struct rect
{
  double x;
  double y;
};
struct polar
{
  double distance;
  double angle;
};
void show_polar(polar dapos)
{
    using namespace std;
    const double Rad_to_deg = 57.29577951;
    cout << dapos.distance << endl;
    cout << dapos.angel * Rad_to_deg;
    cout << endl;
}
```

**2.使用极坐标系(直角坐标转换)**

```cpp
// conver
polar rect_to_polar(rect xypos)
{
    polar answer;
    answer.distance = 
        sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y,xypos.x);
    return answer;
}
```

**3.ALL**

```cpp
// 7.12 atrcfun.cpp
#include<iostream>
#include<cmath>
struct polar
{
  	double distance;
    double angle;
};
struct rect
{
    double x;
    double y;
};
// prototypes
polar rect_to_polar(rect xypos);
void show_polar(polar dapos);

int main()
{
    using namespace std;
    rect rplace;
    polar pplace;
    cout << "Enter x and y" << endl;
    // cin是istream的对象,需要虚函数调用,本地化检查
    while(cin >> rplace.x >> rplace.y)
    {
        pplace = rect_to_polat(rplace);
        show_polar(pplace);
    }
    cout << "Done" << endl;
    return 0;
}
polar rect_to_polar(rect xypos)
{
    using namespace std;
    polar answer;
    answer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);
    answer.angle = atan2(xypos.y,xypos.x);
    return answer;
}
void show_polar(polar dapos)
{
    using namespace std;
    const double Rad_to_deg = 57.29577951;
    cout << dapos.distance;
    cout << dapos.angle * Rad_to_deg;
    cout << endl;
}
```

**需要注意读取数字的方法(和下面的方法进行比较)**

```cpp
// 非格式化输入,绕过了所有高层抽象的场景,一种快速读入模板
for(int i = 0;i < limit;i++)
{
    cout << (i+1) ;
    cin >> temp;
    if(temp < 0)
        break;
    ar[i] = temp;
}
```

**同时`cin`慢的主要原因子啊与和C的同步和绑定**

```cpp
std::ios_base::sync_with_stdio(false);
std::cin.tie(NULL);
```

>   一种高度优化的,基于`getchar()`的逐字符读取是最快的,避免了检查

## 3.传递结构的地址

和前面说的一样,需要一个指向结构的指针,需要修改以下的调用:

>   调用函数时,将结构的地址传递给函数:`pplace`->`&pplace`
>
>   将形参声明为指向`polar`的指针,即`polar*`类型并使用`const`避免修改
>
>   因为形参是指针不是结构,所以应该使用`->`而不是`.`

```cpp
// show polar.cpp
void show_polar(const polar* pda)
{
    using namespace std;
    const double Rad_to_deg = 57.29577951;
    cout << pda -> distance;
    cout << pda -> angle * Rad_to_deg;
    cout << endl;
}
```

```cpp
// 7.13 strctptr.cpp
#include<iostream>
#include<cmath>
struct polar
{
    double distance;
    double angle;
};
struct rect
{
    double x;
    double y;
};
// prototypes
void rect_to_polar(const rect* pxy , polar* pda);
void show_polar(const polar* pda);

int main()
{
    using namespace std;
    rect rplace;
    polar pplace;
    while(cin >> rplace.x >> rplace.y)
    {
        rect_to_polar(&rplace,&pplace);
        show_polar(&pplace);
    }
    cout << "Done\n";
    return 0;
}
void show_polar(const polar* pda)
{
    using namespace std;
    const double Rad_to_dog = 57.29577951;
    cout << pda->distance;
    cout << pda->angle * Rad_to_dog; // 这里的*是乘法运算符
    cout << " degrees\n";
}
void rect_to_polar(const rect* pxy,polar* pda)
{
    using namespace std;
    pda->distance = sqrt(pxy->x * pxy->x + pxy->y * pxy->y);
    pda->angle = atan2(pxy->y,pxy->x);
}
```

