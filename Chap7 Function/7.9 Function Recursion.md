# 7.9 Function Recursion

## 1.包含一个递归调用的函数

```cpp
void recurs(args)
{
    statements1;
    if(test)
 		recurs(args);
    statements2;
}
```

**只要if语句为`true`,每个`recurs`都会执行`statement1`**

```cpp
// 7.16 recur.cpp
#include<iostream>
void countdown(int n);
int main()
{
    countdown(4);
    return 0;
}
void countdown(int n)
{
    using namespace std;
    cout << n << " at " << &n << endl;
    if(n > 0)
        countdown(n - 1);
    cout << n << " at " << &n << endl;
}
/*
	4 at 0x7fff0afe0e4c
    3 at 0x7fff0afe0e2c
    2 at 0x7fff0afe0e0c
    1 at 0x7fff0afe0dec
    0 at 0x7fff0afe0dcc
    0 at 0x7fff0afe0dcc
    1 at 0x7fff0afe0dec
    2 at 0x7fff0afe0e0c
    3 at 0x7fff0afe0e2c
    4 at 0x7fff0afe0e4c
*/
/*
	e4c - e3c = 20 -> 2*16^1 + 0*16^0 = 32字节
	这里的32是函数调用创建的完整栈帧的大小
*/
```

**在一个内存单元(内存地址为`0012RE0C`)**

## 2.包含多个递归调用的递归

对于多个递归调用的递归,就像从标尺的两端到中间(U-net的形状)

```cpp
// 7.17 ruler.cpp
#include<iostream>
const int Len = 66;
const int Divs = 6;
void subdivide(char ar[], int low , int high , int level);
int main()
{
    char ruler[Len];
    int i;
    for(i = 1;i<Len - 2;i++)
        ruler[i] = ' ';
    int max = Len -2;
    int min = 0;
    ruler[min] = ruler[max] = '|';
    std::cout << ruler << std::endl;
    for(i = 1;i <= Divs; i++)
    {
        subdivide(ruler,min,max,i);
        std::cout << ruler << std::endl;
        for(int j =1;j < Len - 2;j++)
            ruler[j] = ' ';
    }
    return 0;
}
void subdivide(cahr ar[],int low,int high,int level)
{
    if(level == 0)
        return;
    int mid = (high + low) / 2;
    ar[mid] = '|';
    subdivide(ar,low,mid,level - 1);
    subdivide(ar,mid,high,level - 1);
}
```

>   `subdivide()`函数使用变量level来控制递归层

