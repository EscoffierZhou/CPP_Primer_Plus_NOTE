# 4.7 C++的指针和自由存储空间

**首先一个程序必须具有的3个属性(基本策略)**

>   信息存储在何处?  **程序为值分配内存,并跟踪内存单元**
>
>   信息存储的值是?  **为简单变量赋值**
>
>   信息存储的类型是? **在声明语句中声明值的类型和符号名**

**(指针策略)**

>指针是一个变量,存储的是值的地址
>
>如何求得值的地址? **使用地址运算符(&)**

```cpp
// 4.14 address.cpp
#include<iostream>
int main()
{			
    using namespace std;
 	int donuts = 6;
 	double cups = 4.5;
 	cout << &donuts << endl;  // 0x7ffd6ac1006c
 	cout << &cups << endl;    // 0x7ffd6ac10060
 	double cups = 4.5;
 	int donuts = 6;
 	cout << &donuts << endl;  // 0x7fffe3724e24
 	cout << &cups << endl;    // 0x7fffe3724e28
 	return 0;
}
```

**内存对齐(Memory Alignment)和编译器优化**

>由于内存是分块存储的,并且需要满足位数的倍数关系,所以中间存在填充
>
>栈(stack)的内存是从高地址到低地址增长的
>
>```cpp
>// 先int后double
>int donuts = 6;		// &donuts -> 0x7ffd6ac1006c  // int(4bit)
>double cups = 4.5;	// &cups   -> 0x7ffd6ac10060  // double(8bit)
>
>// 考虑分配4bit的,6c(十六)->108(十),可被4整除
>// 转换公式(6*16^1 + 12*16^0) = 108
>// donuts:0x7ffd6ac1006c ~ 00x7ffd6ac1006f (4位)
>// 然后分配8bit的,前推8位,0x7ffd6ac10064,64(十六)->100(十),不能被8整除
>// 继续前推,能整除8的是60(十六)->96(十)
>// 所以cups:0x7ffd6ac10060 ~ 0x7ffd6ac10067
>// 存在padding:0x7ffd6ac10068 ~ 0x7ffd6ac1006b
>
>
>// 先doube后int
>double cups = 4.5;  // &cups   -> 0x7fffe3724e28  // double(8bit)
>int donuts = 6;		// &donuts -> 0x7fffe3724e24 // int(4bit)
>// 考虑分配8bit的,28(十六)->40(十),可被8整除
>// 转换公式(2*16^1 + 8*16^0) = 40
>// cups:0x7fffe3724e28 ~ 0x7fffe3724e2f (8位)
>// 然后分配4bit的,0x7fffe3724e28 - 4 = 0x7fffe3724e24
>// 24(十六)->36(十),可被4整除
>// 分配完成
>```
>
>```cpp
>// 验证学习
>int a = 6;			// &a	->	0x7fff53b683ac // int(4bit)
>double b = 4.5;		// &b
>double c = 2.3;		// &c
>double d = 2.1;		// &d
>// 考虑分配4bit的,ac(十六)->28(十),可被4整除
>// 转换公式(10*16^1 + 12*16^0) = 172
>// a:0x7fff53b683ac ~ 0x7fff53b683af
>
>// 考虑分配8bit的,0x7fff53b683ac - 8 = 0x7fff53b683a4
>// a4(十六)->20(十),不能被8整除
>// 转换公式(10*16^1 + 4*16^0) = 164
>// 继续前推,能整除的是a0(十六)->160(十)
>// b:0x7fff53b683a0 ~ 0x7fff53b683a7
>// padding:0x7fff53b683a8 ~ 0x7fff53b683ab
>
>// 考虑分配8bit,前推8位即可(b地址能被整除的)
>// 0x7fff53b683a0 - 8 = 0x7fff53b68398 
>// c:0x7fff53b68398 ~ 0x7fff53b6839f
>
>// 考虑分配8bit,前推8位即可(c地址能被整除的)
>// 0x7fff53b68398  - 8 = 0x7fff53b68390 
>// d:0x7fff53b68390 ~ 0x7fff53b68397 
>
>```

使用常规变量时,值是指定的量,而地址为派生量,以下是**指针与C++基本原理**

>面向对象OOP强调的是在运行阶段进行决策(而非编译阶段)
>
>比如`int[200]`表面上分配了200个数组空间,但是是按照实际情况为准
>
>**所以语言必须允许在运行的时候创建对象**
>
>也就是将值视为指定量,将地址(实际创建的)视为派生量
>
>C++中就使用了关键字`new`请求正确数量的内存以及使用指针确定位置

**解引用符号`*`**

>   处理存储数据(比如读取)的策略和OOP正好相反
>
>   将地址视为指定量,将值视为派生量
>
>   **指针表述的是地址,可以使用解引用符号`*`解除引用,得到具体值**
>
>   ```cpp
>   #include<iostream>
>   int main()
>   {
>   	using namespace std;
>       int updates = 6;
>       int * p_updates;		// 声明指针
>       p_updates = &updates;	// 初始化指针
>       cout << updates << endl;		// 6
>       cout << *p_updates << endl;		// 6
>       cout << *p_updates + 1 << endl; // 7
>       return 0;
>   }
>   ```
>
>   `*p_updates`和`updates`完全等价。可以像使用int变量那样使用`*p_update`

## 1.声明和初始化指针

`int *p_updates`/`double *p_updates`/`char *p_updates`

>   `p_updates`变量本身是`int*`指针
>
>   `*p_updates`是int,而不是指针

```cpp
int ducks = 12; // 此时内存开了空间
int *birddog = &ducks // 此时birddog整型读取的是ducks的内容
cout << *birddog  << endl; // 解引用ducks的地址
```

>   除此之外,格式没有强制要求,但是一般写作`int *ptr`**强调创建了指针并且地址被解引用**
>
>   但是声明多指针一定是`int *p1,*p2`,然而`int *p1,p2`**表示创建了一个指针和一个整型**

**解引用的时候,指针`*`的类型要和解引用对象的`类型`保持一致**

>`*`的行为:告诉编译器从该地址向后读取`sizeof(variety)`个字节(比如`double`就是8字节)
>
>然后按照该类型的编码格式来解释(一般`int* = &double`会直接编译错误)
>
>**如果强行`int* ptr = reinterpret_cast<int*>(&double_num)`会导致解引用错误值**

**虽然指针指向的变量类型可能不同,但是作为指针,他们都占据`2`/`4`字节(1bit)**

**指针也可以直接初始化:`int *pt = &higs;`**

## 2.指针的危险性

C++中创建指针的时候,计算机将分配用来存储地址的内存,但是不会分配该数据的内存

```cpp
long * fellow;  
*fellow = 223323;
// 这里是新手容易犯的错误,认为声明指针后,使用一个数来表示地址进行初始化
// 然而实际中223323被理解为一个int变量,存储在不可被跟踪的位置
// 如果被存在核心代码的内存区/核心数据的内存区,就jier了
```

## 3.指针和数字

和上面说的一样,不能直接将数字作为地址传给指针

```cpp
int *pt;
pt = 0xB8000000 // 错误! 即使是十六进制也不行
pt = (int*)0xB8000000 
```

## 4.使用`new`来分配内存

**1.指针的不同用法**

指针的传统用法:初始化为变量的地址**`指针访问实体变量的地址`**

>   变量是在编译时分配的有名称的内存
>
>   而指针只是为可以通过名称直接访问的内存提供了一个别名。

指针的真正用武之地:在运行阶段分配未命名的内存以存储值。**`指针访问未实例化的地址`**

>   在这种情况下，只能通过指针来访问内存。
>
>   在C语言中，可以库函数`malloc( )`来分配内存；
>
>   在C++中仍然可以`malloc( )`，但C++还有更好的方法`new`运算符。

**2.使用`new`关键字**

在运行阶段为一个`int`值分配未命名的内存,并使用指针来访问这个值

```cpp
int * pn = new int; // 根据类型int来确定需要多少字节的内存
// new int 直接返回一个地址
// pn就是地址,*pn就是地址对应的值
```

```cpp
int higgens;
int *pt = &higgens;
// 一个很明显的指针例子
```

为一个数据对象获得并分配内存的格式:`typeName * pointer_name = new typeName`

需要注意,如果内存不太够导致`new`无法满足,C++会产生值为0的指针,即`nullptr`

**3.栈地址和堆地址(`new`和`*`)**

```cpp
//4.17 use_new.cpp
#include<iostream>
int main()
{
    using namespace std;
    int nights = 1001;
    int *pt = new int;			//pt是指针变量
    *pt = 1001;

    cout << nights << endl;		// 1001
	cout << &nights << endl;	// 0x7ffc91ef75d4
    cout << *pt << endl;		// 1001
	cout << pt << endl;			// 0x91be70
	cout << endl;
    cout << sizeof(pt) << endl; // 8 任何类型的指针都需要8个字节来存储地址
    cout << sizeof(*pt) << endl;// 4 *pt是int类型,4个字节
	
   	cout << endl;
    double *pd = new double;	// pd是指针变量
    // new double程序向堆申请了一块double空间 8字节
    // double *pd程序在栈上创建了pd的指针变量
    cout << *pd << endl;		// 0 读取的是堆的double空间的值,没有初始值
    cout << pd << endl;			// 0xf57ea0 pd指向的堆上的值
    cout << &pd << endl;		// 0x7fff8f69d9e8 pd自己所在的内存地址
    cout << sizeof(*pd) << endl;// 8 *pd是double类型,8个字节
    return 0;
}
```

>   在这里可以看到两种地址:`变量的地址(通过地址运算符计算)`/`变量的地址(通过解除解引用)`
>
>   `&pd`:存储指针变量`pd`本身的内存地址 ->栈中(C++运行栈,栈帧`Frame`--一种临时栈)
>
>   `pd`:指针变量`pd`自身存储的地址 ->堆中(自由存储区`store`)

## 5.使用`delete`释放内存(野指针~!)

当需要内存时,可以使用`new`来请求;当使用完成后,需要将其归还给内存池

>   **如果使用`delete`后面需要加上指向内存块的指针**
>
>   ```cpp
>   int *ps = new int;
>   delete ps; // 会释放ps指向的内存,不会删除ps本身,ps还可以指向另一个内存块
>   ```
>
>   **一定要合理使用`new`和`delete`关键字,否则会发生内存泄漏`(memory leak)`**
>
>   ```cpp
>   int *ps = new int;
>   delete ps; 
>   delete ps; // INVALID!!重复释放
>   
>   int jugs = 5;
>   int *pi = &jugs // 指针变量定义
>   delete pi // INVALID!!还没有分配内存(需要new一个)不能释放
>   // 或者是,这个时候pi指向的是栈内存,而非new的堆内存
>   // delete错误,会直接导致内存泄漏
>       
>   // 正确流程
>   int jugs = 5;
>   int *pi = new int; // new一个
>   *pi = &jugs // 指针变量定义
>   delete pi     
>   // (可选但推荐的好习惯) 将指针设为 nullptr，防止它成为悬挂指针
>   pi = nullptr;
>   ```
>
>   `delete`的关键是`new`是否分配内存,和使用`new`的指针无关(**不建议使用额外指针**)
>
>   ```cpp
>   int *ps = new int;	// 这里通过ps new的空间 
>   int *pq = ps;		// 这里设置了新的指针变量pq,指向new的空间
>   delete pq;			// 空间内存释放(其实不知道是谁释放的)
>   
>   // 这个时候 ps 和 pq 都变成了野指针!!!
>   // 如果继续解引用(灾难)
>   *ps = 123 // 在不存在的内存中写入数据 -> 直接导致程序崩溃(段错误)
>   // 如果继续delete ps(灾难)
>   delete ps // 释放已经释放的内存 -> 立刻崩溃
>       
>   // 解决方法:释放以后手动维护
>   pq = nullptr;
>   ps = nullptr;
>   // 解决方法:在释放内存的时候指定管理者指针(智能指针)
>   #include <memory>
>   std::unique_ptr<int> ps = std::make_unique<int>(); // nullptr
>   std::unique_ptr<int> pq = std::move(ps); // 管理员,pq离开作用域自动释放内存
>   ```

## 6.使用new来创建动态数组

**传统的声明数组和编译称为静态联编(`static building`)**->需要指定长度

**然而动态联编(`dynamic building`)则是在有需要的时候才创建**->动态确定长度

**1.`new`方法创建动态数组**

```cpp
int * psome = new int[10]; // 这时候相当于创建了动态区域,psome是地址
delete [] psome; // 释放动态数组
// 这种写法的目的是:避免只释放指针指的元素,要释放连续的空间
// 注意new和delete需要对应,如果有[]就都有,如果没有[]就都没有
```

>   **不要用`delete`释放不是`new`分配的空间(静态赋值)**
>
>   **不要用`delete`释放同内存两次**
>
>   **对空指针应用`delete`是安全的**

**2.使用动态数组**

```cpp
int * psome = new int[10]; // 这时候相当于创建了动态区域,psome是地址
cout << psome[1] << endl;  // 可以直接访问
```

```cpp
// 4.18 arraynew.cpp
#include<iostream>
int main()
{
    using namespace std;
    double *p3 = new double[3];
    p3[0] = 0.2;
    p3[1] = 0.5;
    p3[2] = 0.8;
    cout << p3[1] << endl; // 0.5
    p3 = p3 + 1;  // 虽然上面把p3视作数组,但是加减法还是基于指针的
    cout << p3[0] << endl; // 0.5
    p3 = p3 - 1;
    delete [] p3;
    return 0;
}
```

