# 4.8 C++的指针/数组/指针算术

**从前面的指针数组可以看出,通过声明指针的移动就可以完成数组的操作**

>   指针和数组基本等价的原因:指针算术和C++内部处理数组的方式
>
>   整数变量+1后,其值也将`+1`
>
>   指针变量+1后,其增加的量为`类型的字节数`(即移动位置)
>
>   ```cpp
>   // 4.19 addpntrs.cpp
>   #include<iostream>
>   int main()
>   {
>   	using namespace std;
>       double wages[3] = {10000.0 , 20000.0 , 30000.0};
>       // 正常行为:内存之间间隔8位
>       // 其中 &wages[0]:0x7ffdd6ed5b90 
>       // 其中 &wages[1]:0x7ffdd6ed5b98
>       // 其中 &wages[2]:0x7ffdd6ed5ba0 
>       // 需要额外注意的是cout后序将小数点截断了
>       short stacks[3] = {3,2,1};
>       // 正常行为:内存之间间隔2位
>       // 其中& stacks[0]: 0x7ffdd6ed5b8a
>       // 其中& stacks[1]: 0x7ffdd6ed5b8c
>       // 其中& stacks[2]: 0x7ffdd6ed5b8e
>       double * pw = wages;
>       double * ps = &stacks[0];  
>       // 危险行为:将double指针指向short数组的地址
>       // 虽然pw的类型是double,wages的类型也是double
>       
>       cout << "pw" << pw << " " << *pw << endl; 
>       // pw 0x7ffdd6ed5b90 10000 (确实是正确的输出)
>       pw = pw + 1;
>       cout << "pw" << pw << " " << *pw << endl; 
>       // pw 0x7ffdd6ed5b98 20000 (确实是正确的输出)
>       // 这里很容易看出来是8bit的大小(double)
>       // 虽然ps的类型是double,但是stacks的类型是short int
>       cout << "ps" << ps << " " << *ps << endl; 
>       // ps 0x7ffdd6ed5b8a 3
>       ps = ps + 1;// !!!主要问题:这里其实加上的sizeof(short)
>       // 一种UD行为,因为编译器不知道是按照数据类型还是按照指针类型
>       cout << "ps" << ps << " " << *ps << endl; 
>       // ps 0x7ffdd6ed5b8c 2
>       
>       // 这里很容易看出来是2bit的大小(short int)
>       // !!危险做法,因为这里的如果要强制输出
>       cout << stacks[0] << " " << stacks[1] << endl;	// 3 2
>       cout << *stacks << " " << *(stacks + 1) << endl; // 3 2
>       
>       cout << sizeof(wages) << endl; 	  // 24
>       cout << sizeof(pw) << endl;		  // 8
>       return 0;
>   }
>   ```
>
>   ```cpp
>   double * pw = wages;
>   wages = &wages[0];
>   // 第一个数组元素的地址
>   ```
>

**1.程序说明**

在多数情况下,C++将数组名解释为第1个元素的地址(`array[0]`)

>   即`wages(数组名) = &wages[0] = 第一个数组元素`
>
>   (这里是一种显式的使用)

因此`double * pw = wages;`表示将pw声明为指向`double`类型的指针,并初始化

**注意`*(stacks + 1)`和`stacks[1]`**

