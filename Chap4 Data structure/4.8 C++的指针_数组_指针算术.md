# 4.8 C++的指针/数组/指针算术

**从前面的指针数组可以看出,通过声明指针的移动就可以完成数组的操作**

>   指针和数组基本等价的原因:指针算术和C++内部处理数组的方式
>
>   整数变量+1后,其值也将`+1`
>
>   指针变量+1后,其增加的量为`类型的字节数`(即移动位置)
>
>   ```cpp
>   // 4.19 addpntrs.cpp
>   #include<iostream>
>   int main()
>   {
>   	using namespace std;
>       double wages[3] = {10000.0 , 20000.0 , 30000.0};
>       // 正常行为:内存之间间隔8位
>       // 其中 &wages[0]:0x7ffdd6ed5b90 
>       // 其中 &wages[1]:0x7ffdd6ed5b98
>       // 其中 &wages[2]:0x7ffdd6ed5ba0 
>       // 需要额外注意的是cout后序将小数点截断了
>       short stacks[3] = {3,2,1};
>       // 正常行为:内存之间间隔2位
>       // 其中& stacks[0]: 0x7ffdd6ed5b8a
>       // 其中& stacks[1]: 0x7ffdd6ed5b8c
>       // 其中& stacks[2]: 0x7ffdd6ed5b8e
>       double * pw = wages;
>       double * ps = &stacks[0];  
>       // 危险行为:将double指针指向short数组的地址
>       // 虽然pw的类型是double,wages的类型也是double
>       
>       cout << "pw" << pw << " " << *pw << endl; 
>       // pw 0x7ffdd6ed5b90 10000 (确实是正确的输出)
>       pw = pw + 1;
>       cout << "pw" << pw << " " << *pw << endl; 
>       // pw 0x7ffdd6ed5b98 20000 (确实是正确的输出)
>       // 这里很容易看出来是8bit的大小(double)
>       // 虽然ps的类型是double,但是stacks的类型是short int
>       cout << "ps" << ps << " " << *ps << endl; 
>       // ps 0x7ffdd6ed5b8a 3
>       ps = ps + 1;// !!!主要问题:这里其实加上的sizeof(short)
>       // 一种UD行为,因为编译器不知道是按照数据类型还是按照指针类型
>       cout << "ps" << ps << " " << *ps << endl; 
>       // ps 0x7ffdd6ed5b8c 2
>       
>       // 这里很容易看出来是2bit的大小(short int)
>       // !!危险做法,因为这里的如果要强制输出
>       cout << stacks[0] << " " << stacks[1] << endl;	// 3 2
>       cout << *stacks << " " << *(stacks + 1) << endl; // 3 2
>       
>       cout << sizeof(wages) << endl; 	  // 24(数组大小)
>       cout << sizeof(pw) << endl;		  // 8 (指针大小)
>       return 0;
>   }
>   ```
>
>   ```cpp
>   double * pw = wages;
>   wages = &wages[0];
>   // 第一个数组元素的地址
>   ```
>

## **1.程序说明**

在多数情况下,C++将数组名解释为第1个元素的地址(`array[0]`)

>   即`wages(数组名) = &wages[0] = 第一个数组元素`
>
>   (这里是一种显式的使用)

因此`double * pw = wages;`表示将pw声明为指向`double`类型的指针,并初始化

**注意`*(stacks + 1)`和`stacks[1]`是等价的(即读取index为1的ui阿莫斯)**

>   但是只有使用指针数组才能如此计算
>
>   ```cpp
>   pointer = pointer + 1; // valid
>   array = array + 1; // INVALID
>   ```

**数组的地址**

>   对数组取地址的时候,数组名被解释为第一个元素的地址
>
>   对数组取地址运算符的时候,得到的是整个数组的地址
>
>   ```cpp
>   short tell[10];
>   cout << tell << endl;
>   cout << &tell << endl;
>   // 虽然输出的地址相同
>   // 但&tell[0]是2字节内存块的地址
>   // 而&tell是包含20个元素的数组
>   // 数组地址的描述:
>   short (*pas)[20] = &tell; // 不能省略括号,否则会声明*pas[20]
>   ```

## **2.指针小结**

```cpp
// 1.声明指针
// typename * pointername;
double *ptr;

// 2.给指针赋值
double bubble = 3.2;
double *ptr1,*ptr2,*ptr3;
ptr1 = &bubble; // 赋值bubble地址
ptr2 = new char; // 赋值新的char地址给ptr
ptr3 = new double[30]; // 将数组的第一个元素地址给ptr

// 3.对指针解引用
cout << *ptr << endl;

// 4.指针和int
int *ptr = new int;
*pt = 5; // 这里pt是地址,*pt其实就是int

// 5.数组名
// 大多情况下,C++将数组名视为数组的第一个元素的地址

// 6.指针算术
int a[10] = {1,2,3,4,5,6,7,8,9,10};
int *pt = a;
pt = pt + 1;
int *pe = &a[9];
pe = pe -1;
int diff = pe - pt;

// 7.数组的动态联编和静态联编
int scores[10];
int size; cint >> size;
int *pz = new int [size];
delete [] pz;

// 8.数组表示法和指针表示法
// 使用方括号数组表示法等同于对指针解除引用
tocos[0] // 表示*tocos
tocos[3] // 表示*(tocos + 3)
```

## 3.指针和字符串

指针+数组+字符串的组合

```cpp
#include <iostream>
using namespace std;

int main()
{
   char flower[10] = "rose";
   cout << flower << endl;	// rose会输出所有内容
   // 因为实际cout接收flower的第一个字符的地址,然后依次读取,最后读到'\0'后停止
   // 在cout和多数C++表达式中,char数组/char指针/字符串常量,都被解释为第一个元素的地址
   cout << &flower << endl; // 0x7fff7d6c3d1e
   char * ptr = flower;
   cout << *(ptr) << endl;	// r
   cout << *(ptr+1) << endl;// o
   cout << *(ptr+2) << endl;// s
   cout << *(ptr+3) << endl;// e    
   return 0;
}
```

```cpp
// 4.20 ptrstr.cpp
#include<iostream>
#include<cstring>
int main()
{
	using namespace std;
    char animal[20] = "bear"; // C风格的字符串
    // 修改内容只能使用strcpy_s,strcpy来复制完成
    const char * bird = "wren";
    // 如果使用过很多次字符串字面值"wren"可能只有一个复变
    char *ps;
    cout << animal << " " << bird << endl; // bear wren
    cin >> animal;
    ps = animal; // 其实这里是建立的地址的等式
    
    cout << ps << " " << (int *)ps << endl;  
    // hachimi 0x7ffc2dc53420
    cout << animal << " " << (int*)animal << endl;
    // hachimi 0x7ffc2dc53420
    
    ps = new char[strlen(animal) + 1];
    // new操作符在堆上找到了足够大的内存,并且覆盖了原来ps的地址
    // +1的原因是存在'\0'占位符额外占据空间
    strcpy(ps,animal);
    // 直接使用ps = animal;是INVALID的,因为会修改ps的地址,新的空间无法再访问了
    // 通过使用strcpy()和new关键字,获得animal此时字符串的两个独立副本
    // 初始化数组,请一定使用'='运算符,否则应该使用strcpy()和strncpy()
    // 初始化字符串数组,请一定使用使用strcpy()和strncpy()(不能使用赋值运算符)
    // strncpy()避免字符串剩余部分复制进来时,覆盖正常运行程序的内存
    
    cout << ps << " " << (int *)ps << endl;
    // hachimi 0x2341e90
    cout << animal << " " << (int*)animal << endl;
    // hachimi 0x7ffc2dc53420
    delete []ps;
    return 0;
}
```

## 4.使用`new`创建动态结构

在运行时创建数据结构(动态) > 在编译时创建数据结构(静态)

**1.创建一个未命名的`inflatable`类型,并将其地址赋给一个指针**

```cpp
inflatable * ps = new inflatable;
```

**2.访问动态结构成员(使用`->`)**

```cpp
struct things
{
  int good;
  int bad;
};
things grubnose = {3,123}; // 新建一个结构体
things * pt = &grubnose	  // 创建指针指向该结构体
pt -> good; // 指向的是grubnose.good
pt -> bad;  // 指向的是grubnose.bad
```

`pt -> good`其实是一种语法糖:`(*pt).good`,也就是`name.good;`

```cpp
// 4.21 newstruct.cpp
#include<iostream>
struct inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
	using namespace std;
    inflatable * ps = new inflatable;
    cin.get(ps->name,20);
    cin >> ps->price;
    cout << (*ps).name << endl;
    cout << ps->volume << endl;
    cout << ps->price << endl;
    delete ps;
    return 0;
}
```

**3.使用`new`和`delete`的示例**

假设程序要读取100个字符串

>   如果用`char`数组,则需要`1000`个数组,每个数组`80`个字节,一共`80000`个字节
>
>   如果用`pointer`+`char`数组,创建1000个指向`char`的指针,根据`new`来动态分配空间

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char *getname(void); // prototype
int main()
{
    char *name;
   	name = getname();
    cout << name << " " << (int *)name << endl; // CIEL 0x7efe80
    delete [] name;
    name = getname();
    cout << name << " " << (int *)name << endl; // KAFU 0x7efe80
    delete [] name;
    return 0;
}
char *getname()
{
	char temp[80];
    cin >> temp;
    char *pn = new char[strlen(temp) + 1];
    strcpy(pn,temp);
    return pn;
}
```

需要注意`getname()`的用法,将`cin`输入的单词放到`temp`中,然后使用`new`分配内存

## 5.自动存储/静态存储/动态存储

C++11其实一共有4种存储方式:自动存储/静态存储/线程存储

**1.自动存储**

在函数内部定义的常规变量使用自动存储空间,称为自动变量`automatic variable`

>   自动变量在函数调用时自动产生,在函数结束时自动消亡
>
>   自动变量是一个局部变量,它的作用域就是一段代码
>
>   **自动变量通常存储在栈中,符合LIFO原则**

**2.静态存储**

在整个程序执行期间都存在的存储方式

>   使变量成为静态的方式:在函数外面定义它
>
>   使变量成为静态的方式:在声明变量时使用关键字`static`
>
>   自动存储和静态存储的关键在于:这些方法严格限制了变量的寿命

**3.动态存储**

`new`和`delete`运算符提供了更灵活的方式

>   动态存储在单独的C++自由存储空间(堆)
>
>   数据的生命舟曲不完全受程序或函数的生存时间控制
>
>   内存管理更复杂了
>
>   在栈中:自动添加和自动删除使得大多数占用的空间是连续的
>
>   栈堆中:new和delete的相互影响使得占用的堆空间不连续

**(4.栈/堆/内存泄漏)**

>   主要指的是使用`new`运算符在堆上创建变量,但是没有调用`delete`删除
>
>   **指针受到(作用域/对象生命周期)原因释放,但是自由存储空间上动态分配的变量继续存在**
>
>   **然后这些变量无法访问并删除,内存被分配但是无法收回,导致内存耗尽,程序崩溃**
