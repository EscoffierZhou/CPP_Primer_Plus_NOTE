# 4.5 C++的共用体

**共用体(`union`)是一种数据格式,能够存储不同的数据类型**

**<font color=red>但是只能同时存储其中一种类型的一个值,主要作用是节省内存</font>**

## 1.创建使用共用体

```cpp
struct BadValue { // 没有使用共用体
    int i;
    float f;
    char c;
    // 内存消耗是 4+4+1+3 = 12 Bit
    // 如果存储的是整数,就浪费了f和c的空间
};

union ValueUnion { // 使用共用体
    int i;
    float f;
    char c;
    // 内存消耗是动态的,当前存储成员的最大值
};
```

(一个`union`的大小由它最大的成员决定)

```cpp
// 但是现实中,避免结构体和输出不匹配,常用enum+switch来做map
#include <iostream>
// 1. 定义一个枚举类型作为“标签”，指明当前存储的是哪种类型
enum class ValueType {
    Integer,
    Float,
    Char
};

// 2. 将 union 和 enum 封装在一个结构体中
struct Value {
    ValueType type; // 标签
    union {         // 匿名的 union
        int i;
        float f;
        char c;
    };
};

void printValue(const Value& val) {
    // 3. 根据标签来安全地访问 union 的成员
    switch (val.type) {
        case ValueType::Integer:
            std::cout << "Integer: " << val.i << std::endl;
            break;
        case ValueType::Float:
            std::cout << "Float: " << val.f << std::endl;
            break;
        case ValueType::Char:
            std::cout << "Char: " << val.c << std::endl;
            break;
    }
}

int main() {
    Value v1;
    v1.type = ValueType::Integer;
    v1.i = 123;
    printValue(v1);

    Value v2;
    v2.type = ValueType::Float;
    v2.f = 3.14f;
    printValue(v2);
}
```

**然而在C++17中,直接使用`std::variant`**

```cpp
#include <iostream>
#include <variant>
#include <string>

// 不需要手动管理标签！
using MyValue = std::variant<int, float, std::string>;

int main() {
    MyValue v = 123; // 它现在是 int
    std::cout << "Index: " << v.index() << std::endl; 
    // index() 告诉你当前是第几种类型
    std::cout << "Value: " << std::get<int>(v) << std::endl;

    v = 3.14f; // 它现在变成了 float
    std::cout << "Index: " << v.index() << std::endl;
    std::cout << "Value: " << std::get<float>(v) << std::endl;

    // 如果你访问了错误的类型，它会抛出异常，而不是产生未定义行为，非常安全！
    try {
        std::get<int>(v);
    } catch (const std::bad_variant_access& e) {
        std::cout << "Error: " << e.what() << std::endl;
    }
```

## 2.匿名共用体`anonymous`

**由于共用体的内存相同,所以不需要中间标识符`id_val`**

```cpp
struct widget
{
	char brand[20];
    int type;
    union{
      long id_num;
      char id_char[20];
    };
};

widget prize;

if (prize.type == 1){
    cin >> prize.id_num;
}else{
    cin >> prize.id_char;
}
```

