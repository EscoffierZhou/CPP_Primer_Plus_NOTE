# 4.2 C++的字符串

C++处理字符串的方法两种:基于char的C-风格字符串/基于string库的方法

C-风格字符串具有特殊性质:以空字符`\0`结尾(ASCII码为0)

>   ```cpp
>   char dog[8] = {'f', 'a' , 't' , 'e' , 's' , 's' ,  'a' , '\0'};
>   char bird[11] = "Mr.Cheeps"; // automatic '\0'
>   ```
>
>   **所以如果也可能存在输出提前截断的情况**
>
>   ```cpp
>   #include<iostream>
>   int main()
>   {
>      using namespace std;
>      char dog[8] = {'f', 'a' , 't' , '\0' , 's' , 's' ,  'a' , '\0'};
>   	cout << dog << endl; // fat
>   }
>   ```
>
>   **确定字符串所需最短数组时,记得结尾处的空字符以及中间的空格(仍是\0)**

**char的`''`和string的`""`**

>   在char中,`char shirt_size = 'S';`会直接赋值S对应的ASCII码
>
>   string中,`"char shirt_size = "S";`会直接将`S\0`的地址赋值(报错)

## **1.拼接字符串**

以下的C++字符串拼接都是等价的

```cpp
cout << "I Love CIEL\n";
cout << "I Love ""CIEL\n";
cout << "I Love "
    "CIEL\n";
```

## **2.在数组中使用字符串**

```cpp
// 4.2 strings.cpp
#include<iostream>
#include<cstring>
int main()
{
	using namespace std;
    const int Size = 15;
    char name1[Size] = "CIEL";          // empty
    // char name1[Size];name1 = "CIEL"; //ILLEGAL
    char name2[Size] = "C++owboy" ;// initialized
    name2[3] = '\0';
    
    cout << strlen(name1) << endl;		// 4
    cout << name1[0] << endl;			// C
    cout << name2 << endl;				// C++
    return 0;
}
```

**`sizeof()`和`strlen()`**

>   `sizeof()` 表示的是数组的字节数
>
>   `strlen()`表示的是字符串除了空白符`\0`的字符串长度

## **3.字符串输入(通过空格隔断)**

```cpp
// 4.3 instr1.cpp
#include<iostream>
int main()
{
    using namespace std;
    const int Arsize = 20;
    char name[Arsize];
    char dessert[Arsize];
    cin >> name;
    cin >> dessert;
    cout << name << " likes " << dessert << endl;
    return 0;
}
```

>   实际输入:`CIEL Strawberry`就会直接显示`CIEL likes Strawberry`
>
>   因为`cin`直接通过空白(**空格/制表符/换行符**)来确定字符串结尾部分

## **4.字符串输入(每行)`getline()`和`get()`**

1.面向行的输入`getline()`

>   `getline()`读取整行,通过回车键输入的换行符确定输入结尾**(丢弃换行符)**
>
>   `cin.getline(name,number)`:存储输入行的数组名称 + 读取的字符数-1(`\0`)
>
>   ```cpp
>   //4.4 instr2.cpp
>   #include<iostream>
>   int main()
>   {
>      using namespace std;
>      const int Arsize = 20;
>      char name[Arsize];
>      char dessert[Arsize];
>      cin.getline(name,ArSize);
>      cin.getline(dessert,ArSize);
>      cout << name << " likes " << dessert << endl;
>      return 0;
>   }
>   ```

2.面向行的输入`get()`

>   `istream`中有另一个`get()`成员函数,**但是不会丢弃换行符**
>
>   (即如果两段输入之间存在换行符,则会导致错误)
>
>   ```cpp
>      cin.get(name,ArSize);
>   	cin.get()  // read newline
>      cin.get(dessert,ArSize);
>   
>   	cin.get(name,ArSize).get(); // concatenate(输入和回车键的组合)
>   
>   	cin.getline(name1,ArSize).getline(name2,ArSize) // concatenate
>   ```
>
>   ```cpp
>   // 4.5 instr3.cpp
>   #include<iostream>
>   int main()
>   {
>      using namespace std;
>      const int Arsize = 20;
>      char name[Arsize];
>      char dessert[Arsize];
>      cin.get(name,ArSize).get();
>      cin.get(dessert,ArSize).get();
>      cout << name << " likes " << dessert << endl;
>      return 0;
>   }
>   ```

3.失效位(failbit)

>   1.当`getline()`或`get()`得到的是空行,会设置失效位,阻断后序输入
>
>   2.输入比可分配空间长,`get`会将余项留在输入队列,`getline`额外设置fb
>
>    long a[] = {25,92,3.0} // long int中存在小数char c[] = {'h','i',1122011} //不合法只能到128char n[] = {'h','i',112} //合法cpp

****

## **5.混合输入字符串和数字**

>   ```cpp
>   // 4.6 numstr.cpp
>   #include<iostream>
>   int main()
>   {
>   	using namespace std;
>      int year;
>      cin >> year;
>      // 解决方法1 : cin.get()清除换行符
>      // 解决方法2 : concatenate (cin >> year).get();
>      char address[80]
>      cin.getline(address,80);
>      cout << year << endl;
>      cout << address << endl;
>      return 0;
>   }
>   // 在这里用户根本无法输入address,因为换行符还被保留,导致getline()直接为空
>   ```

**基于string类的方法**

```cpp
//4.7 strtype1.cpp
#include<iostream>
#include<string>
int main()
{
	using namespace std;
    char charr1[20];
    char charr2[20] = "jaguar";
    string str1;
    string str2 = "panther";
    cin >> charr1;
    cin >> str1;
    cout << charr1 << charr2 << endl;
    cout << charr2[2] << endl;
    cout << str2[2] << endl;
    return 0;
}
```

>   可以使用`C-风格`初始化`string`兑现那个
>
>   可以使用`cin`将对象输入到`string`对象中
>
>   可以使用`cout`将`string`对象输出
>
>   可以使用数组访问存储在`string`对象中的字符
>
>   (可以将`string`对象声明为简单变量,而不是数组)
>
>   (类设计能够自动处理`string`的大小)
