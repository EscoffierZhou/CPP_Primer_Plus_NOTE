# 5.2 while-loop

该条件为非0时,会使得测试-执行部分一直进行下去

```cpp
#include<iostream>
const int ArSize = 20;
int main()
{
	using namespace std;
    char name[ArSize];
    cin >> name;
    int i = 0;
    while(name[i] != '\0') // 当然while(name[i])也是合法的
    {
        cout << name[i] << int(name[i]) << endl;
        // 输出:单个字符+字符数组的地址
        i++;
    }
    return 0;
}
```

## **1.`for`和`while`**

在C++中`for`和`while`本质上是相同的,但是也存在以下区别

>   **(1)for循环省略了测试条件,将其认定为`true`**
>
>   **(2)for循环中可以使用初始化语句声明局部变量,`while不可以`**
>
>   **(3)两个循环的`continue`处理条件不同**

## **2.编写延时循环**

字面意思,通过设置较大的数值,让`while`循环执行的时间变长

但是`ANSI C`和`C++`中都有一个库:`clock()`,一种`long`类型的常量

或者头文件`ctime`中的符号常量`CLOCKS_PER_SEC`

```cpp
// 5.14 waiting.cpp
#include <iostream>
#include <ctime> 

int main()
{
   using namespace std;
   float secs;
   cin >> secs;

   clock_t delay = secs * CLOCKS_PER_SEC;
   cout << "Starting..." << endl;
   clock_t start = clock();
   while (clock() - start < delay);
   cout << "Done! Waited " << secs << " seconds." << endl;

   return 0;
}
/*
Starting...
Done! Waited 5 seconds.

Time limit exceeded
*/
```

## **3.类型别名**

C++为类型建立别名的方式1:使用预处理器

>   ```cpp
>#define BYTE char
>   ```

C++为类型建立别名的方式1:使用`typedef`

>   `typedef`只会重命名类型名,而不会重新创建新的类型
>
>   ```cpp
>   typedef char byte; // typedef typeName NewName
>   typedef char* byte_pointer;
>#define FLOAT_POINTER float * // 声明一系列变量的时候不适用
>   FLOAT_POINTER pa,pb // pa是pointer但是pb只是float
>```